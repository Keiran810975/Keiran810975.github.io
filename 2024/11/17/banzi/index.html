<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/huh.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/huh.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="DFS，BFS，dp，贪心，图论，计算几何滑动窗口，分治，二分，手撕STL，单调栈，单调队列常用函数(快速幂，高精度，费马小定理，排序……)">
<meta property="og:type" content="article">
<meta property="og:title" content="(大合集)算法板子+经典题代码">
<meta property="og:url" content="http://example.com/2024/11/17/banzi/index.html">
<meta property="og:site_name" content="PIGMilk的博客">
<meta property="og:description" content="DFS，BFS，dp，贪心，图论，计算几何滑动窗口，分治，二分，手撕STL，单调栈，单调队列常用函数(快速幂，高精度，费马小定理，排序……)">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-11-17T01:41:59.000Z">
<meta property="article:modified_time" content="2024-12-19T16:18:48.403Z">
<meta property="article:author" content="PIGMilk">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2024/11/17/banzi/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2024/11/17/banzi/","path":"2024/11/17/banzi/","title":"(大合集)算法板子+经典题代码"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>(大合集)算法板子+经典题代码 | PIGMilk的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">PIGMilk的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">PIGMIlk's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li><li class="menu-item menu-item-个人简介"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>个人简介</a></li><li class="menu-item menu-item-分类"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%BE%E7%82%B9%EF%BC%9A%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">难点：头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E5%BA%93%E4%B8%80%E4%BA%9B%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">STL库一些容器的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue"><span class="nav-number">2.1.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">2.2.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pair"><span class="nav-number">2.3.</span> <span class="nav-text">pair</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">2.4.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">2.5.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-number">2.6.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-number">2.7.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-number">2.8.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-map"><span class="nav-number">2.9.</span> <span class="nav-text">unordered_map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS"><span class="nav-number">3.</span> <span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">3.1.</span> <span class="nav-text">全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">组合数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98-%E6%9C%80%E5%A5%BD%E7%94%A8BFS"><span class="nav-number">3.3.</span> <span class="nav-text">迷宫问题(最好用BFS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%AA%E6%B0%B4%E7%81%8C%E6%BA%89%E6%A8%A1%E5%9E%8B-%E4%B9%9F%E5%8F%AF%E4%BB%A5BFS"><span class="nav-number">3.4.</span> <span class="nav-text">洪水灌溉模型(也可以BFS)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS"><span class="nav-number">4.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98"><span class="nav-number">4.1.</span> <span class="nav-text">迷宫问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B5%B7%E7%82%B9BFS-%E6%B4%9B%E8%B0%B7%EF%BC%9A%E8%A1%80%E8%89%B2%E5%85%88%E9%94%8B%E9%98%9F"><span class="nav-number">4.2.</span> <span class="nav-text">多起点BFS(洛谷：血色先锋队)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97BFS-%E5%B0%8F%E6%98%8E%E7%9A%84%E6%B8%B8%E6%88%8F"><span class="nav-number">4.3.</span> <span class="nav-text">双端队列BFS(小明的游戏)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E8%B5%B7%E7%82%B9BFS-%E4%BC%98%E5%8C%96%E7%A6%BB%E5%BC%80%E4%B8%AD%E5%B1%B1%E8%B7%AF"><span class="nav-number">4.4.</span> <span class="nav-text">双向起点BFS(优化离开中山路)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFS%EF%BC%8C%E4%BD%86%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E5%BF%85%E9%A1%BB%E6%98%AF3%E7%9A%84%E5%80%8D%E6%95%B0"><span class="nav-number">4.5.</span> <span class="nav-text">BFS，但路径长度必须是3的倍数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">5.</span> <span class="nav-text">滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">5.1.</span> <span class="nav-text">定长滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%EF%BC%9A%E9%95%BF%E5%BA%A6%E4%B8%BAk%E7%9A%84%E5%8C%BA%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">5.1.1.</span> <span class="nav-text">模板：长度为k的区间的子串最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1"><span class="nav-number">5.1.2.</span> <span class="nav-text">1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">6.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85"><span class="nav-number">6.1.</span> <span class="nav-text">01背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">6.1.1.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%80%9D%E8%B7%AF"><span class="nav-number">6.1.2.</span> <span class="nav-text">01背包的另一个思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%B0%E5%A5%BD%E8%A3%85%E6%BB%A1%E5%9E%8B01%E8%83%8C%E5%8C%85-1"><span class="nav-number">6.1.3.</span> <span class="nav-text">恰好装满型01背包(1)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%B0%E5%A5%BD%E8%A3%85%E6%BB%A1%E5%9E%8B01%E8%83%8C%E5%8C%85-2"><span class="nav-number">6.1.4.</span> <span class="nav-text">恰好装满型01背包(2)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">6.2.</span> <span class="nav-text">完全背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-number">6.3.</span> <span class="nav-text">多重背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF-1"><span class="nav-number">6.3.1.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.2.</span> <span class="nav-text">多重背包的二进制优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%EF%BC%9A%E6%AF%8F%E7%BB%84%E8%87%B3%E5%A4%9A-%E5%8F%AA%E8%83%BD%E9%80%89%E4%B8%80%E4%B8%AA"><span class="nav-number">6.4.</span> <span class="nav-text">分组背包：每组至多&#x2F;只能选一个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7dp"><span class="nav-number">6.5.</span> <span class="nav-text">线性dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS"><span class="nav-number">6.5.1.</span> <span class="nav-text">最长递增子序列(LIS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LIS%E4%BC%98%E5%8C%96%EF%BC%9A%E8%B4%AA%E5%BF%83-%E4%BA%8C%E5%88%86"><span class="nav-number">6.5.2.</span> <span class="nav-text">LIS优化：贪心+二分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LIS%E5%8F%98%E5%BC%8F%EF%BC%9A%E5%B1%B1%E5%BD%A2%E5%BA%8F%E5%88%97"><span class="nav-number">6.5.3.</span> <span class="nav-text">LIS变式：山形序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">6.5.4.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">6.5.5.</span> <span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E6%88%90%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%8C%E6%9C%80%E5%B0%91%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">6.5.6.</span> <span class="nav-text">变成回文串，最少需要添加几个字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">6.5.7.</span> <span class="nav-text">删除操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">6.5.8.</span> <span class="nav-text">编辑距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">6.5.9.</span> <span class="nav-text">交错字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#s%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%AD%EF%BC%8Ct%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0-oj-buaa"><span class="nav-number">6.5.10.</span> <span class="nav-text">s的子序列中，t出现的个数(oj-&gt;buaa)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BAdp"><span class="nav-number">6.6.</span> <span class="nav-text">状态机dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8"><span class="nav-number">6.6.1.</span> <span class="nav-text">买卖股票</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96-%E6%9C%89%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="nav-number">6.6.2.</span> <span class="nav-text">股票买卖(有冷冻期)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%A1%E9%87%91%E5%B8%81"><span class="nav-number">6.7.</span> <span class="nav-text">捡金币</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%8D%A1%E9%87%91%E5%B8%81"><span class="nav-number">6.7.1.</span> <span class="nav-text">一维捡金币</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%8D%A1%E9%87%91%E5%B8%81"><span class="nav-number">6.7.2.</span> <span class="nav-text">二维捡金币</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%92%E5%88%86DP"><span class="nav-number">6.8.</span> <span class="nav-text">划分DP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86"><span class="nav-number">6.8.1.</span> <span class="nav-text">数组划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">6.8.2.</span> <span class="nav-text">单词拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E5%89%B2%E5%87%BA%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">6.8.3.</span> <span class="nav-text">切割出回文串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%92%A2%E7%AE%A1%E5%88%87%E5%89%B2"><span class="nav-number">6.8.4.</span> <span class="nav-text">钢管切割</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">6.9.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E8%A3%85%E9%85%8D"><span class="nav-number">6.9.1.</span> <span class="nav-text">工厂装配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-1"><span class="nav-number">6.9.2.</span> <span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95"><span class="nav-number">6.9.3.</span> <span class="nav-text">最长回文子串(马拉车算法)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">6.9.4.</span> <span class="nav-text">乘积最大子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%82%E8%89%B2%EF%BC%8Ck%E7%A7%8D%E9%A2%9C%E8%89%B2%EF%BC%8C%E4%B8%94%E5%90%8C%E9%A2%9C%E8%89%B2%E6%9C%80%E5%A4%9A%E8%BF%9E%E7%BB%AD%E4%B8%A4%E4%B8%AA"><span class="nav-number">6.9.5.</span> <span class="nav-text">涂色，k种颜色，且同颜色最多连续两个</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83"><span class="nav-number">7.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%BA%8F%E5%88%97%E9%85%8D%E5%AF%B9-%E4%BB%8E%E6%9C%80%E5%B0%8F-%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0%E5%BC%80%E5%A7%8B%E8%B4%AA%E5%BF%83"><span class="nav-number">7.1.</span> <span class="nav-text">双序列配对(从最小&#x2F;大的元素开始贪心)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC"><span class="nav-number">7.1.1.</span> <span class="nav-text">田忌赛马</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%AE%BA"><span class="nav-number">8.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8-DFS%EF%BC%8CBFS%EF%BC%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%8CPrim%EF%BC%8CFloyd%EF%BC%8CBellman-Ford%EF%BC%8CDijkstra"><span class="nav-number">8.1.</span> <span class="nav-text">邻接矩阵存储(DFS，BFS，拓扑排序，Prim，Floyd，Bellman-Ford，Dijkstra)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8-DFS%EF%BC%8CBFS%EF%BC%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%8CKruskal%EF%BC%8CFloyd%EF%BC%8CBellman-Ford%EF%BC%8CDijkstra"><span class="nav-number">8.2.</span> <span class="nav-text">邻接表存储(DFS，BFS，拓扑排序，Kruskal，Floyd，Bellman-Ford，Dijkstra)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">8.3.</span> <span class="nav-text">并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E4%BC%98%E5%8C%96"><span class="nav-number">8.3.1.</span> <span class="nav-text">无优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9-%E4%B8%8E-%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6-%E4%BC%98%E5%8C%96"><span class="nav-number">8.3.2.</span> <span class="nav-text">路径压缩 与 按秩合并 优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="nav-number">9.</span> <span class="nav-text">网络流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dinic%E7%AE%97%E6%B3%95"><span class="nav-number">9.1.</span> <span class="nav-text">Dinic算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E4%B8%AAdinic"><span class="nav-number">9.2.</span> <span class="nav-text">另一个dinic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dinic-from-%E5%8A%A9%E6%95%99"><span class="nav-number">9.3.</span> <span class="nav-text">Dinic from 助教</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">10.</span> <span class="nav-text">二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="nav-number">10.1.</span> <span class="nav-text">二分图的判定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%9D%83%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-number">10.2.</span> <span class="nav-text">无权最大匹配(匈牙利算法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9D%83%E5%8C%B9%E9%85%8D"><span class="nav-number">10.3.</span> <span class="nav-text">带权二分图的最小权匹配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="nav-number">11.</span> <span class="nav-text">计算几何</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%82%E7%BA%BF%E6%AE%B5"><span class="nav-number">11.1.</span> <span class="nav-text">垂线段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%8C%E7%9B%B8%E4%BA%A4%E7%9A%84%E5%88%A4%E6%96%AD"><span class="nav-number">11.2.</span> <span class="nav-text">平行相交的判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%BA%BF%E6%AE%B5%E7%9A%84%E4%BA%A4%E7%82%B9%E5%9D%90%E6%A0%87"><span class="nav-number">11.3.</span> <span class="nav-text">求两个线段的交点坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%82%B9%E5%85%B1%E7%BA%BF%E5%88%A4%E6%96%AD"><span class="nav-number">11.4.</span> <span class="nav-text">三点共线判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E4%BA%94%E5%BF%83"><span class="nav-number">11.5.</span> <span class="nav-text">三角形五心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E6%8B%89%E6%B1%89%E5%A7%86%E6%89%AB%E6%8F%8F-Graham-Scan-%E8%AE%A1%E7%AE%97%E9%9D%A2%E7%A7%AF"><span class="nav-number">11.6.</span> <span class="nav-text">格拉汉姆扫描(Graham Scan)+计算面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Andrew%E6%89%AB%E6%8F%8F%E6%B3%95-%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%E6%B3%95%E6%B1%82%E5%87%B8%E5%8C%85%E4%B8%AD%E4%B8%A4%E7%82%B9%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB"><span class="nav-number">11.7.</span> <span class="nav-text">Andrew扫描法+旋转卡壳法求凸包中两点最大距离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">12.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP"><span class="nav-number">12.1.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP-from-%E5%8A%A9%E6%95%99"><span class="nav-number">12.2.</span> <span class="nav-text">KMP from 助教</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E5%87%BD%E6%95%B0%CE%B4-x-c"><span class="nav-number">12.3.</span> <span class="nav-text">转移函数δ(x,c)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">12.4.</span> <span class="nav-text">有限状态机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">13.</span> <span class="nav-text">其他常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gcd"><span class="nav-number">13.1.</span> <span class="nav-text">gcd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lcm"><span class="nav-number">13.2.</span> <span class="nav-text">lcm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A0%E6%95%B0"><span class="nav-number">13.3.</span> <span class="nav-text">素数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">13.4.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95"><span class="nav-number">13.5.</span> <span class="nav-text">大数乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">13.6.</span> <span class="nav-text">矩阵快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">13.7.</span> <span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6"><span class="nav-number">13.7.1.</span> <span class="nav-text">从右到左</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3"><span class="nav-number">13.7.2.</span> <span class="nav-text">从左到右</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9B%E6%89%A3962%EF%BC%9A%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E5%9D%A1"><span class="nav-number">13.7.3.</span> <span class="nav-text">力扣962：最大宽度坡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">13.8.</span> <span class="nav-text">单调队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-number">13.9.</span> <span class="nav-text">傅里叶变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FFT"><span class="nav-number">13.9.1.</span> <span class="nav-text">FFT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FFT-from-%E5%8A%A9%E6%95%99"><span class="nav-number">13.9.2.</span> <span class="nav-text">FFT from 助教</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%86%E5%BA%8F%E7%BD%AE%E6%8D%A2"><span class="nav-number">13.9.3.</span> <span class="nav-text">逆序置换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3"><span class="nav-number">13.10.</span> <span class="nav-text">同余方程的最小正整数解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ax-%E2%89%A1-1-mod-b"><span class="nav-number">13.10.1.</span> <span class="nav-text">ax ≡ 1 (mod b)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ax-%E2%89%A1-b-mod-n"><span class="nav-number">13.10.2.</span> <span class="nav-text">ax ≡ b (mod n)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E6%90%93%E5%A0%86"><span class="nav-number">13.11.</span> <span class="nav-text">手搓堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3"><span class="nav-number">13.12.</span> <span class="nav-text">质因数分解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="nav-number">13.13.</span> <span class="nav-text">字典树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%88%A9%E6%81%AF"><span class="nav-number">13.14.</span> <span class="nav-text">银行利息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">14.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%92%E6%B3%A1"><span class="nav-number">14.1.</span> <span class="nav-text">冒泡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">14.2.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6"><span class="nav-number">14.3.</span> <span class="nav-text">归并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%BA%8Fk%E5%80%8D%E5%AF%B9-%E5%A6%82%E6%9E%9C-1-%E2%89%A4-i-j%E2%89%A4n-%E4%B8%94-ai-k%E2%8B%85aj"><span class="nav-number">14.4.</span> <span class="nav-text">逆序k倍对(如果 1 ≤ i &lt; j≤n 且 ai &gt; k⋅aj)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">14.5.</span> <span class="nav-text">折半插入排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">15.</span> <span class="nav-text">时间复杂度</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PIGMilk"
      src="/images/turtle.png">
  <p class="site-author-name" itemprop="name">PIGMilk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Keiran810975" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Keiran810975" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:23676866@qq.com" title="E-Mail → mailto:23676866@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/yourname" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/yourname" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/yourname" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/yourname" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/yourname" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
      <span class="links-of-author-item">
        <a href="skype:yourname?call|chat" title="Skype → skype:yourname?call|chat" rel="noopener me" target="_blank"><i class="fab fa-skype fa-fw"></i>Skype</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/17/banzi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/turtle.png">
      <meta itemprop="name" content="PIGMilk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PIGMilk的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="(大合集)算法板子+经典题代码 | PIGMilk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          (大合集)算法板子+经典题代码
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-11-17 09:41:59" itemprop="dateCreated datePublished" datetime="2024-11-17T09:41:59+08:00">2024-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-20 00:18:48" itemprop="dateModified" datetime="2024-12-20T00:18:48+08:00">2024-12-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><strong>DFS，BFS，dp，贪心，图论，计算几何<br>滑动窗口，分治，二分，手撕STL，单调栈，单调队列<br>常用函数(快速幂，高精度，费马小定理，排序……)</strong></p>
<span id="more"></span>

<hr>
<h2 id="难点：头文件"><a href="#难点：头文件" class="headerlink" title="难点：头文件"></a><del>难点：头文件</del></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C艹</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入输出（I/O）相关</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// 用于输入输出流（如 cin, cout）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>        <span class="comment">// 用于文件输入输出流（如 ifstream, ofstream）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>        <span class="comment">// 用于字符串流（如 istringstream, ostringstream）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span>         <span class="comment">// C 标准库的输入输出（如 printf, scanf）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>        <span class="comment">// 用于格式化输出（如 setw, setprecision）</span></span></span><br><span class="line"><span class="comment">// 容器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>         <span class="comment">// 向量容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span>           <span class="comment">// 双向链表容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>          <span class="comment">// 双端队列容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span>            <span class="comment">// 集合容器（无重复元素）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>            <span class="comment">// 映射容器（键值对）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span>  <span class="comment">// 无序集合容器（哈希表实现）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span>  <span class="comment">// 无序映射容器（哈希表实现）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span>          <span class="comment">// 固定大小数组容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span>          <span class="comment">// 栈容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span>          <span class="comment">// 队列容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;priority_queue&gt;</span> <span class="comment">// 优先队列容器</span></span></span><br><span class="line"><span class="comment">// 算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>      <span class="comment">// 常用算法（如 sort, find, binary_search 等）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>     <span class="comment">// 用于函数对象、标准函数及绑定器等</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span>        <span class="comment">// 数值计算相关函数（如 accumulate）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>       <span class="comment">// 迭代器相关工具</span></span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>         <span class="comment">// 字符串类（如 std::string）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>        <span class="comment">// C 风格字符串（如 strcpy, strlen 等）</span></span></span><br><span class="line"><span class="comment">// 数学和数值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>          <span class="comment">// 常见数学函数（如 sin, cos, sqrt）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>        <span class="comment">// C 标准库的实用函数（如 rand, exit）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>          <span class="comment">// 时间和日期函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span>         <span class="comment">// 数值限制（如 numeric_limits）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span>        <span class="comment">// 复数类型和运算</span></span></span><br><span class="line"><span class="comment">// 类型和常用工具</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span>    <span class="comment">// 类型特性（如 is_integral, is_floating_point）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>        <span class="comment">// 实用工具（如 swap, move）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>          <span class="comment">// 元组类型及相关功能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span>         <span class="comment">// 位集合容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdbool.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="STL库一些容器的用法"><a href="#STL库一些容器的用法" class="headerlink" title="STL库一些容器的用法"></a>STL库一些容器的用法</h2><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">stu</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自定义比较器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> stu&amp; a, <span class="type">const</span> stu&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.id &gt; b.id; <span class="comment">// 小根堆，id 较小的优先级高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.second == b.second) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;  <span class="comment">// `second` 相同时比较 `first` 升序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;    <span class="comment">// 按 `second` 升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//优先队列</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;<span class="comment">//小根堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq2; <span class="comment">// 大根堆</span></span><br><span class="line">    priority_queue&lt;stu, vector&lt;stu&gt;, cmp&gt; pq3; <span class="comment">// 自定义比较器</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt;&gt; pq;<span class="comment">//放pair的大根堆</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; pq;<span class="comment">//放pair的小根堆</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, less&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; pq;<span class="comment">//降序</span></span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    pq.<span class="built_in">size</span>();</span><br><span class="line">    pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">empty</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">size</span>()</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">10</span>);<span class="comment">//改变大小</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//在尾部插入</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">1</span>);<span class="comment">//在尾部插入</span></span><br><span class="line">v.<span class="built_in">pop_back</span>();<span class="comment">//删除尾部</span></span><br><span class="line">v.<span class="built_in">clear</span>();<span class="comment">//清空</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>()<span class="number">+1</span>,v.<span class="built_in">begin</span>()<span class="number">+3</span>);<span class="comment">//删除区间</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>()<span class="number">+1</span>,<span class="number">1</span>);<span class="comment">//插入单个元素</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>()<span class="number">+1</span>,<span class="number">3</span>,<span class="number">1</span>);<span class="comment">//插入多个元素</span></span><br><span class="line">v.<span class="built_in">front</span>();<span class="comment">//第一个元素</span></span><br><span class="line">v.<span class="built_in">back</span>();<span class="comment">//最后一个元素</span></span><br><span class="line">v.<span class="built_in">empty</span>();<span class="comment">//判空</span></span><br><span class="line">v.<span class="built_in">swap</span>(v2);<span class="comment">//交换</span></span><br><span class="line"><span class="comment">//遍历(三种方法)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    cout&lt;&lt;v[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:v)&#123;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">pii pp;</span><br><span class="line">p.first;</span><br><span class="line">p.second;</span><br></pre></td></tr></table></figure>


<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">count</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:s)&#123;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt; mp;</span><br><span class="line">myMap[<span class="number">1</span>] = <span class="string">&quot;One&quot;</span>;</span><br><span class="line">myMap[<span class="number">2</span>] = <span class="string">&quot;Two&quot;</span>;</span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="string">&quot;Three&quot;</span>&#125;);</span><br><span class="line">myMap.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">//删除键</span></span><br><span class="line">myMap.<span class="built_in">clear</span>(); <span class="comment">//清空</span></span><br><span class="line"><span class="comment">//find() 查找键是否存在(返回的是迭代器)</span></span><br><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">2</span>);  <span class="comment">// 查找键为 2 的元素</span></span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//count() 查找是否有某个键(返回0或1)</span></span><br><span class="line"><span class="keyword">if</span> (myMap.<span class="built_in">count</span>(<span class="number">2</span>)) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key 2 exists&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Key 2 does not exist&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用基于范围的 for 循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">    cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">back</span>();</span><br><span class="line">q.<span class="built_in">size</span>();</span><br><span class="line">q.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>

<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">dq.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">dq.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">dq.<span class="built_in">pop_back</span>();</span><br><span class="line">dq.<span class="built_in">pop_front</span>();</span><br><span class="line">dq.<span class="built_in">front</span>();</span><br><span class="line">dq.<span class="built_in">back</span>();</span><br><span class="line">dq.<span class="built_in">size</span>();</span><br><span class="line">dq.<span class="built_in">empty</span>();</span><br><span class="line"><span class="comment">//下标访问元素</span></span><br><span class="line">dq[<span class="number">0</span>]</span><br><span class="line"><span class="comment">//at()</span></span><br><span class="line">dq.<span class="built_in">at</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">st.<span class="built_in">top</span>();</span><br><span class="line">st.<span class="built_in">size</span>();</span><br><span class="line">st.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>

<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义哈希函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair_hash</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="type">const</span> std::pair&lt;T1, T2&gt;&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> h1 = std::hash&lt;T1&gt;&#123;&#125;(p.first);   <span class="comment">// 哈希键的第一个元素</span></span><br><span class="line">        <span class="keyword">auto</span> h2 = std::hash&lt;T2&gt;&#123;&#125;(p.second);  <span class="comment">// 哈希键的第二个元素</span></span><br><span class="line">        <span class="keyword">return</span> h1 ^ h2;  <span class="comment">// 合并哈希值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">unordered_map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>, pair_hash&gt; map;<span class="comment">//直接用索引访问就行</span></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">    <span class="comment">//if(it-&gt;second&gt;=2)cnt++;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> st[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">permutation</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d &quot;</span>,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            st[i]=<span class="number">1</span>;</span><br><span class="line">            arr[x]=i;</span><br><span class="line">            <span class="built_in">permutation</span>(x<span class="number">+1</span>);</span><br><span class="line">            st[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//arr[x]=0;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">permutation</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=n;i++)&#123;</span><br><span class="line">        arr[x]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(x<span class="number">+1</span>,i<span class="number">+1</span>);</span><br><span class="line">        arr[x]=<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迷宫问题-最好用BFS"><a href="#迷宫问题-最好用BFS" class="headerlink" title="迷宫问题(最好用BFS)"></a>迷宫问题(最好用BFS)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> w,h;</span><br><span class="line"><span class="type">char</span> maze[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> st[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span>||a&gt;=h||b&lt;<span class="number">0</span>||b&gt;=w)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(maze[a][b]!=<span class="string">&#x27;.&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(st[a][b])<span class="keyword">continue</span>;</span><br><span class="line">        st[a][b]=<span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">dfs</span>(a,b);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w,&amp;h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,maze[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;w;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maze[i][j]==<span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                st[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i,j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="洪水灌溉模型-也可以BFS"><a href="#洪水灌溉模型-也可以BFS" class="headerlink" title="洪水灌溉模型(也可以BFS)"></a>洪水灌溉模型(也可以BFS)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">char</span> g[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span>||a&gt;=n||b&lt;<span class="number">0</span>||b&gt;=m)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(g[a][b]==<span class="string">&#x27;.&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(st[a][b])<span class="keyword">continue</span>;</span><br><span class="line">        st[a][b]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;W&#x27;</span>&amp;&amp;st[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="built_in">dfs</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> x,y,xx,yy;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line">queue &lt;pii&gt; q;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x1,y1&#125;);</span><br><span class="line">    dis[x1][y1]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pii t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=t.first+dx[i],b=t.second+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">1</span>||a&gt;n||b&lt;<span class="number">1</span>||b&gt;n)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[a][b]!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[a][b]!=<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">            dis[a][b]=dis[t.first][t.second]<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a==xx&amp;&amp;b==yy)<span class="keyword">return</span> dis[xx][yy];</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[xx][yy];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;xx,&amp;yy);</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">bfs</span>(x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多起点BFS-洛谷：血色先锋队"><a href="#多起点BFS-洛谷：血色先锋队" class="headerlink" title="多起点BFS(洛谷：血色先锋队)"></a>多起点BFS(洛谷：血色先锋队)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line">queue &lt;pii&gt; q;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pii t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=t.first+dx[i],b=t.second+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">1</span>||a&gt;n||b&lt;<span class="number">1</span>||b&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[a][b])<span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">            dis[a][b]=dis[t.first][t.second]<span class="number">+1</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">        dis[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[x][y]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列BFS-小明的游戏"><a href="#双端队列BFS-小明的游戏" class="headerlink" title="双端队列BFS(小明的游戏)"></a>双端队列BFS(小明的游戏)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> xx,yy;</span><br><span class="line"><span class="type">char</span> g[<span class="number">550</span>][<span class="number">550</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">550</span>][<span class="number">550</span>];</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">deque &lt;pii&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;x,y&#125;);</span><br><span class="line">    dis[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        pii t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=t.first+dx[i],b=t.second+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">0</span>||a&gt;=n||b&lt;<span class="number">0</span>||b&gt;=m)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[a][b]!=<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[a][b]==g[t.first][t.second])&#123;</span><br><span class="line">                dis[a][b]=dis[t.first][t.second];</span><br><span class="line">                q.<span class="built_in">push_front</span>(&#123;a,b&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(g[a][b]!=g[t.first][t.second])&#123;</span><br><span class="line">                dis[a][b]=dis[t.first][t.second]<span class="number">+1</span>;</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;a,b&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a==xx&amp;&amp;b==yy)&#123;</span><br><span class="line">                <span class="keyword">return</span> dis[a][b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">if</span>(!n&amp;&amp;!m)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x0,y0;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x0,&amp;y0,&amp;xx,&amp;yy);</span><br><span class="line">        <span class="type">int</span> res=<span class="built_in">bfs</span>(x0,y0);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向起点BFS-优化离开中山路"><a href="#双向起点BFS-优化离开中山路" class="headerlink" title="双向起点BFS(优化离开中山路)"></a>双向起点BFS(优化离开中山路)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span> x,y,xx,yy;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">queue &lt;pii&gt; q;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;xx,yy&#125;);</span><br><span class="line">    dis[x][y]=<span class="number">0</span>,dis[xx][yy]=<span class="number">0</span>;</span><br><span class="line">    vis[x][y]=<span class="number">1</span>,vis[xx][yy]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pii t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a=t.first+dx[i],b=t.second+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">1</span>||a&gt;n||b&lt;<span class="number">1</span>||b&gt;n)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[a][b]!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[a][b]+vis[t.first][t.second]==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> dis[a][b]+dis[t.first][t.second]<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dis[a][b]!=<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            dis[a][b]=dis[t.first][t.second]<span class="number">+1</span>;</span><br><span class="line">            vis[a][b]=vis[t.first][t.second];</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%1d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;xx,&amp;yy);</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">bfs</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BFS，但路径长度必须是3的倍数"><a href="#BFS，但路径长度必须是3的倍数" class="headerlink" title="BFS，但路径长度必须是3的倍数"></a>BFS，但路径长度必须是3的倍数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line">	step[s][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	v[s][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> x=q.<span class="built_in">front</span>().first;</span><br><span class="line">		<span class="type">int</span> y=q.<span class="built_in">front</span>().second;</span><br><span class="line">		q.<span class="built_in">pop</span>(); </span><br><span class="line">		<span class="type">int</span> yy=(y<span class="number">+1</span>)%<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[x].<span class="built_in">size</span>();i++)</span><br><span class="line">			<span class="keyword">if</span>(!v[g[x][i]][yy])</span><br><span class="line">			&#123;</span><br><span class="line">				v[g[x][i]][yy]=<span class="number">1</span>;</span><br><span class="line">				step[g[x][i]][yy]=step[x][y]<span class="number">+1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(&#123;g[x][i],yy&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="定长滑动窗口"><a href="#定长滑动窗口" class="headerlink" title="定长滑动窗口"></a>定长滑动窗口</h3><h4 id="模板：长度为k的区间的子串最大值"><a href="#模板：长度为k的区间的子串最大值" class="headerlink" title="模板：长度为k的区间的子串最大值"></a>模板：长度为k的区间的子串最大值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">findMaxAverage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=-INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;k<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">        sum-=nums[i-k<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)ans/k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###不定长滑动窗口</p>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    h[s[l]]=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">1</span>;r&lt;n;r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h[s[r]])&#123;</span><br><span class="line">            <span class="keyword">while</span>(s[l]!=s[r])&#123;</span><br><span class="line">                h[s[l]]=<span class="literal">false</span>;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        h[s[r]]=<span class="literal">true</span>;</span><br><span class="line">        cnt=r-l<span class="number">+1</span>;</span><br><span class="line">        maxc=<span class="built_in">max</span>(maxc,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cap;<span class="comment">//总容量</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">1000</span>],v[<span class="number">1000</span>];<span class="comment">//体积和价值</span></span><br><span class="line"><span class="type">int</span> cache[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//i表示第i件物品（选不选），c表示包内剩余容量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cache[i][c]!=<span class="number">-1</span>)<span class="keyword">return</span> cache[i][c];</span><br><span class="line">    <span class="keyword">if</span>(c&lt;w[i])<span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>,c);</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,c),<span class="built_in">dfs</span>(i<span class="number">-1</span>,c-w[i])+v[i]);</span><br><span class="line">    cache[i][c]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=cap;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//选不了</span></span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;j)f[i<span class="number">+1</span>][j]=f[i][j];</span><br><span class="line">            <span class="comment">//可以选</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j]=<span class="built_in">max</span>(f[i][j],f[i][j-w[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][cap]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化(节省空间)</span></span><br><span class="line"><span class="type">int</span> ff[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=cap;j&gt;=w[i];j--)&#123;</span><br><span class="line">            ff[j]=<span class="built_in">max</span>(ff[j],ff[j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cache,<span class="number">-1</span>,<span class="keyword">sizeof</span> cache);</span><br><span class="line">    cin&gt;&gt;cap&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,dfs(n-1,cap));</span></span><br><span class="line">     <span class="built_in">dp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="01背包的另一个思路"><a href="#01背包的另一个思路" class="headerlink" title="01背包的另一个思路"></a>01背包的另一个思路</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n,contain;</span><br><span class="line"><span class="type">int</span> v,w;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MM=<span class="number">250000</span>;</span><br><span class="line"><span class="type">int</span> f[MM<span class="number">+1</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;contain);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=MM;i++)&#123;</span><br><span class="line">        f[i]=contain<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;v,&amp;w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=MM;j&gt;=w;j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">min</span>(f[j],f[j-w]+v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=MM;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[j]&lt;=contain)&#123;</span><br><span class="line">            res=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="恰好装满型01背包-1"><a href="#恰好装满型01背包-1" class="headerlink" title="恰好装满型01背包(1)"></a>恰好装满型01背包(1)</h4><p>力扣2915<br>给你一个下标从 0 开始的整数数组 nums 和一个整数 target 。<br>返回和为 target 的 nums 子序列中，子序列 长度的最大值 。如果不存在和为 target 的子序列，返回 -1 。<br>子序列 指的是从原数组中删除一些或者不删除任何元素后，剩余元素保持原来的顺序构成的数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubsequence</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(target<span class="number">+1</span>,INT_MIN)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum+nums[i]&gt;target)sum=target;</span><br><span class="line">        <span class="keyword">else</span> sum+=nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=nums[i];j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-nums[i]]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[target]&gt;<span class="number">0</span> ? f[target] : <span class="number">-1</span>;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="恰好装满型01背包-2"><a href="#恰好装满型01背包-2" class="headerlink" title="恰好装满型01背包(2)"></a>恰好装满型01背包(2)</h4><p>给你一个 只包含正整数 的 非空 数组 nums 。<br>请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)sum+=nums[i];</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> cap=sum/<span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(sum<span class="number">+1</span>,INT_MIN)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        s=(s+nums[i]&gt;cap)?cap:s+nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=s;j&gt;=nums[i];j--)&#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-nums[i]]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> f[cap]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cap;<span class="comment">//总容量</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">1000</span>],v[<span class="number">1000</span>];<span class="comment">//体积和价值</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=cap;j++)&#123;</span><br><span class="line">            <span class="comment">//选不了</span></span><br><span class="line">            <span class="keyword">if</span>(j&lt;w[i])f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">//可以选</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j-w[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f2[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=cap;j++)&#123;</span><br><span class="line">            f2[j]=<span class="built_in">max</span>(f2[j],f2[j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f2[cap]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cache,<span class="number">-1</span>,<span class="keyword">sizeof</span> cache);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;cap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;v[i];</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][cap]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cap;           <span class="comment">// 总容量</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">1000</span>], v[<span class="number">1000</span>], num[<span class="number">1000</span>]; <span class="comment">// 体积、价值和每种物品的数量限制</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>]; <span class="comment">// 动态规划数组</span></span><br><span class="line"><span class="type">int</span> n;             <span class="comment">// 物品种类数</span></span><br><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 逆序遍历背包容量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = cap; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 遍历每个物品的数量限制</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * w[i] &lt;= j; k++) &#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j] = <span class="built_in">max</span>(f[i<span class="number">+1</span>][j], f[i][j - k * w[i]] + k * v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][cap]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空间优化版动态规划</span></span><br><span class="line"><span class="type">int</span> ff[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 逆序遍历容量，防止重复使用物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = cap; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 每件物品最多选 num[i] 次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * w[i] &lt;= j; k++) &#123;</span><br><span class="line">                ff[j] = <span class="built_in">max</span>(ff[j], ff[j - k * w[i]] + k * v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ff[cap]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; cap &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; num[i]; <span class="comment">// 输入体积、价值和数量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dp</span>();     <span class="comment">// 使用二维数组的解法</span></span><br><span class="line">    <span class="comment">// dp2(); // 使用空间优化后的解法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多重背包的二进制优化"><a href="#多重背包的二进制优化" class="headerlink" title="多重背包的二进制优化"></a>多重背包的二进制优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cap; </span><br><span class="line"><span class="type">int</span> w[<span class="number">150</span>], v[<span class="number">150</span>], num[<span class="number">150</span>]; </span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cap + <span class="number">1</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> quantity = num[i];</span><br><span class="line">        <span class="type">int</span> weight = w[i];</span><br><span class="line">        <span class="type">int</span> value = v[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= quantity; k *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> numItems = <span class="built_in">min</span>(k, quantity);  <span class="comment">// 取出最小的数量（1, 2, 4...）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = cap; j &gt;= numItems * weight; --j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - numItems * weight] + numItems * value);</span><br><span class="line">            &#125;</span><br><span class="line">            quantity -= numItems; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (quantity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = cap; j &gt;= quantity * weight; --j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - quantity * weight] + quantity * value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[cap] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; cap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; num[i] &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dp2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组背包：每组至多-只能选一个"><a href="#分组背包：每组至多-只能选一个" class="headerlink" title="分组背包：每组至多&#x2F;只能选一个"></a>分组背包：每组至多&#x2F;只能选一个</h3><p>n个骰子，每个骰子有k和面，点数从1到k，问有多少种方案使得点数之和等于target</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target&lt;n||target&gt;n*k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(target<span class="number">+1</span>));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target-n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">0</span>;h&lt;k&amp;&amp;h&lt;=j;h++)&#123;</span><br><span class="line">                f[i][j]+=f[i<span class="number">-1</span>][j-h];</span><br><span class="line">                f[i][j]%=m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][target-n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h3><h4 id="最长递增子序列-LIS"><a href="#最长递增子序列-LIS" class="headerlink" title="最长递增子序列(LIS)"></a>最长递增子序列(LIS)</h4><p><strong>(Dilworth定理：最少的不上升子序列的个数就是最长上升子序列的长度)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp数组f，f[i]代表以nums[i]结尾的严格递增子序列的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        f[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LIS优化：贪心-二分"><a href="#LIS优化：贪心-二分" class="headerlink" title="LIS优化：贪心+二分"></a>LIS优化：贪心+二分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; g;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = ranges::<span class="built_in">lower_bound</span>(g, x);</span><br><span class="line">        <span class="keyword">if</span> (it == g.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            g.<span class="built_in">push_back</span>(x); <span class="comment">// &gt;=x 的 g[j] 不存在</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *it = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LIS变式：山形序列"><a href="#LIS变式：山形序列" class="headerlink" title="LIS变式：山形序列"></a>LIS变式：山形序列</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumMountainRemovals</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">suf</span><span class="params">(n)</span>, g</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i; i--) &#123;</span><br><span class="line">        <span class="type">int</span> x = nums[i];</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), x);</span><br><span class="line">        suf[i] = it - g.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 从 nums[i] 开始的最长严格递减子序列的长度</span></span><br><span class="line">        <span class="keyword">if</span> (it == g.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            g.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *it = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    g.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = nums[i];</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), x);</span><br><span class="line">        <span class="type">int</span> pre = it - g.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 在 nums[i] 结束的最长严格递增子序列的长度</span></span><br><span class="line">        <span class="keyword">if</span> (it == g.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            g.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *it = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt;= <span class="number">2</span> &amp;&amp; suf[i] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, pre + suf[i] - <span class="number">1</span>); <span class="comment">// 减去重复的 nums[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n - mx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">1000</span>],t[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==t[j])<span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,j),<span class="built_in">dfs</span>(i,j<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s),m=<span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[j])f[i<span class="number">+1</span>][j<span class="number">+1</span>]=f[i][j]<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i<span class="number">+1</span>][j<span class="number">+1</span>]=<span class="built_in">max</span>(f[i][j<span class="number">+1</span>],f[i<span class="number">+1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s,t);</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">dfs</span>(<span class="built_in">strlen</span>(s)<span class="number">-1</span>,<span class="built_in">strlen</span>(t)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cache[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;j)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cache[i][j]!=<span class="number">-1</span>)<span class="keyword">return</span> cache[i][j];</span><br><span class="line">    <span class="keyword">if</span>(i==j)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==s[j])<span class="keyword">return</span> <span class="built_in">dfs</span>(i<span class="number">+1</span>,j<span class="number">-1</span>)<span class="number">+2</span>;</span><br><span class="line">    <span class="type">int</span> a=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">+1</span>,j),<span class="built_in">dfs</span>(i,j<span class="number">-1</span>));</span><br><span class="line">    cache[i][j]=a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">+1</span>][j<span class="number">-1</span>]<span class="number">+2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j]=<span class="built_in">max</span>(f[i<span class="number">+1</span>][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cache,<span class="number">-1</span>,<span class="keyword">sizeof</span> cache);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">dfs</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变成回文串，最少需要添加几个字符"><a href="#变成回文串，最少需要添加几个字符" class="headerlink" title="变成回文串，最少需要添加几个字符"></a>变成回文串，最少需要添加几个字符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">1100</span>];   </span><br><span class="line"><span class="type">int</span> f[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n<span class="number">-1</span>;l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+l&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> j=i+l;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">+1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j]=<span class="built_in">min</span>(f[i<span class="number">+1</span>][j],f[i][j<span class="number">-1</span>])<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[<span class="number">0</span>][n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=word<span class="number">1.l</span>ength(),m=word<span class="number">2.l</span>ength();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)f[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)f[<span class="number">0</span>][i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j]=<span class="built_in">min</span>(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j])<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> f[n][m];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=word<span class="number">1.l</span>ength(),m=word<span class="number">2.l</span>ength();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)f[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)f[<span class="number">0</span>][i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j]=<span class="built_in">min</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">min</span>(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]))<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> f[n][m];           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s<span class="number">1.l</span>ength(), m = s<span class="number">2.l</span>ength(), t = s<span class="number">3.l</span>ength();</span><br><span class="line">    <span class="keyword">if</span> (n + m != t) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 长度不匹配，直接返回 false</span></span><br><span class="line">    <span class="comment">// 使用一维 DP 数组优化空间</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 初始化 dp[0] 表示空串匹配情况</span></span><br><span class="line">    <span class="comment">// 处理 s2 和 s3 的匹配情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        dp[j] = dp[j - <span class="number">1</span>] &amp;&amp; (s2[j - <span class="number">1</span>] == s3[j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历 s1 和 s2，更新 dp 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">0</span>] &amp;&amp; (s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]); <span class="comment">// 处理 s1 和 s3 的匹配情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[j] = (dp[j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]) || (dp[j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="s的子序列中，t出现的个数-oj-buaa"><a href="#s的子序列中，t出现的个数-oj-buaa" class="headerlink" title="s的子序列中，t出现的个数(oj-&gt;buaa)"></a>s的子序列中，t出现的个数(oj-&gt;buaa)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = s.<span class="built_in">length</span>(), n = t.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[i][n] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">char</span> sChar = s.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">char</span> tChar = t.<span class="built_in">at</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (sChar == tChar) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态机dp"><a href="#状态机dp" class="headerlink" title="状态机dp"></a>状态机dp</h3><h4 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inf -1e9</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> prices[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> cache[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//最开始不可能持有股票</span></span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">return</span> inf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cache[i][flag]!=<span class="number">-1</span>)<span class="keyword">return</span> cache[i][flag];</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,<span class="number">1</span>),<span class="built_in">dfs</span>(i<span class="number">-1</span>,<span class="number">0</span>)-prices[i]);</span><br><span class="line">        cache[i][flag]=a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,<span class="number">0</span>),<span class="built_in">dfs</span>(i<span class="number">-1</span>,<span class="number">1</span>)+prices[i]);</span><br><span class="line">        cache[i][flag]=a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>]=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        f[i<span class="number">+1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(f[i][<span class="number">1</span>],f[i][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        f[i<span class="number">+1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(f[i][<span class="number">0</span>],f[i][<span class="number">1</span>]+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cache,<span class="number">-1</span>,<span class="keyword">sizeof</span> cache);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;prices[i];</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">dfs</span>(n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="股票买卖-有冷冻期"><a href="#股票买卖-有冷冻期" class="headerlink" title="股票买卖(有冷冻期)"></a>股票买卖(有冷冻期)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖出之后，第二天不能买入</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf -1e9</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> prices[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> cache[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//最开始不可能持有股票</span></span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="keyword">return</span> inf;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cache[i][flag]!=<span class="number">-1</span>)<span class="keyword">return</span> cache[i][flag];</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,<span class="number">1</span>),<span class="built_in">dfs</span>(i<span class="number">-2</span>,<span class="number">0</span>)-prices[i]);</span><br><span class="line">        cache[i][flag]=a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">max</span>(<span class="built_in">dfs</span>(i<span class="number">-1</span>,<span class="number">0</span>),<span class="built_in">dfs</span>(i<span class="number">-1</span>,<span class="number">1</span>)+prices[i]);</span><br><span class="line">        cache[i][flag]=a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>]=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        f[i<span class="number">+1</span>][<span class="number">1</span>]=<span class="built_in">max</span>(f[i][<span class="number">1</span>],f[i][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        f[i<span class="number">+1</span>][<span class="number">0</span>]=<span class="built_in">max</span>(f[i][<span class="number">0</span>],f[i][<span class="number">1</span>]+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cache,<span class="number">-1</span>,<span class="keyword">sizeof</span> cache);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;prices[i];</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">dfs</span>(n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捡金币"><a href="#捡金币" class="headerlink" title="捡金币"></a>捡金币</h3><h4 id="一维捡金币"><a href="#一维捡金币" class="headerlink" title="一维捡金币"></a>一维捡金币</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> t,x,y;</span><br><span class="line">&#125;a[<span class="number">10010</span>];</span><br><span class="line">ll n,k,dp[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		ll x,y,z;cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">		a[i].t=x;a[i].x=y;a[i].y=z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		dp[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="type">int</span> z=<span class="built_in">abs</span>(a[i].x-a[j].x)+<span class="built_in">abs</span>(a[i].y-a[j].y);</span><br><span class="line">			<span class="keyword">if</span>(a[j].t+z&lt;=a[i].t)dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维捡金币"><a href="#二维捡金币" class="headerlink" title="二维捡金币"></a>二维捡金币</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="function">ll <span class="title">dis</span><span class="params">(ll x1, ll y1, ll x2, ll y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x1 - x2) + <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ll x, y, t;</span><br><span class="line">&#125; coin;</span><br><span class="line"><span class="function">ll <span class="title">max</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较coin-&gt;t</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((coin *)a)-&gt;t - ((coin *)b)-&gt;t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">        coin c[n<span class="number">+1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;c[i].x, &amp;c[i].y, &amp;c[i].t);</span><br><span class="line">        &#125;</span><br><span class="line">        ll f[n<span class="number">+1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        c[<span class="number">0</span>].x=c[<span class="number">0</span>].y=c[<span class="number">0</span>].t=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">qsort</span>(c<span class="number">+1</span>, n, <span class="built_in">sizeof</span>(coin), cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f[i]=-inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dis</span>(c[i].x,c[i].y,c[j].x,c[j].y)&lt;=c[i].t-c[j].t)&#123;</span><br><span class="line">                    f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="划分DP"><a href="#划分DP" class="headerlink" title="划分DP"></a>划分DP</h3><h4 id="数组划分"><a href="#数组划分" class="headerlink" title="数组划分"></a>数组划分</h4><p>如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分：</p>
<ul>
<li>子数组 恰 由 2 个相等元素组成，例如，子数组 [2,2] 。</li>
<li>子数组 恰 由 3 个相等元素组成，例如，子数组 [4,4,4] 。</li>
<li>子数组 恰 由 3 个连续递增元素组成，并且相邻元素之间的差值为 1 。例如，子数组 [3,4,5] ，但是子数组 [1,3,5] 不符合要求。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] ||</span><br><span class="line">            i &gt; <span class="number">1</span> &amp;&amp; f[i - <span class="number">2</span>] &amp;&amp; (nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">2</span>] ||nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">2</span>] + <span class="number">2</span>)) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h4><p>给一个词典，判断一个字符串是否可以拆分成字典里的若干个单词</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max_len = ranges::<span class="built_in">max</span>(wordDict, &#123;&#125;, &amp;string::length).<span class="built_in">length</span>();<span class="comment">// 单词长度的最大值</span></span><br><span class="line">    <span class="function">unordered_set&lt;string&gt; <span class="title">words</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="built_in">max</span>(i - max_len, <span class="number">0</span>); j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[j] &amp;&amp; words.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i - j))) &#123;</span><br><span class="line">                f[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切割出回文串"><a href="#切割出回文串" class="headerlink" title="切割出回文串"></a>切割出回文串</h4><p>把一个字符串切割成若干段，每一段都是回文串，求最少切割次数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">st</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="comment">//先维护一个st数组，st[i][j]表示s[i]~s[j]是否为回文串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = j; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                st[i][j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j - i + <span class="number">1</span> == <span class="number">2</span>)</span><br><span class="line">                st[i][j] = (s[i] == s[j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st[i][j] = (s[i] == s[j]) &amp;&amp; st[i<span class="number">+1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[<span class="number">0</span>][j])</span><br><span class="line">            f[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[j] = f[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i][j])</span><br><span class="line">                    f[j] = <span class="built_in">min</span>(f[j], f[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="钢管切割"><a href="#钢管切割" class="headerlink" title="钢管切割"></a>钢管切割</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钢管切割问题的动态规划解决方案</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rodCutting</span><span class="params">(<span class="type">int</span> price[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 长度为0的钢管没有收益</span></span><br><span class="line">    <span class="comment">// 填充dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            maxProfit = <span class="built_in">max</span>(maxProfit, price[j - <span class="number">1</span>] + dp[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> price[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">20</span>&#125;;  <span class="comment">// 各长度钢管的价格表</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(price) / <span class="built_in">sizeof</span>(price[<span class="number">0</span>]);    <span class="comment">// 钢管的最大长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">rodCutting</span>(price, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="工厂装配"><a href="#工厂装配" class="headerlink" title="工厂装配"></a>工厂装配</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> profit[<span class="number">11</span>][<span class="number">16</span>];  <span class="comment">// profit[i][j]表示第 i 个公司分配 j 台设备的盈利</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">11</span>][<span class="number">16</span>];      <span class="comment">// dp[i][j]表示前 i 个公司分配 j 台设备的最大盈利</span></span><br><span class="line"><span class="type">int</span> path[<span class="number">11</span>][<span class="number">16</span>][<span class="number">11</span>]; <span class="comment">// path[i][j][k]表示在状态 (i, j) 时，第 i 个公司分配了 k 台设备</span></span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读入公司数 N 和设备数 M</span></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="comment">// 读入每个公司分配不同数量设备的盈利</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            cin &gt;&gt; profit[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 dp 数组为负无穷，表示未计算的状态</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">// 初始化 base case</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 没有公司，没有设备时，盈利为 0</span></span><br><span class="line">    <span class="comment">// 动态规划计算最大盈利</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; k++) &#123;</span><br><span class="line">                <span class="comment">// 如果分配 k 台设备给第 i 个公司，更新 dp[i][j]</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j - k] != <span class="number">-1</span>) &#123; <span class="comment">// 检查上一个状态是否有效</span></span><br><span class="line">                    <span class="type">int</span> new_profit = dp[i - <span class="number">1</span>][j - k] + profit[i][k];</span><br><span class="line">                    <span class="keyword">if</span> (new_profit &gt; dp[i][j]) &#123;</span><br><span class="line">                        dp[i][j] = new_profit;</span><br><span class="line">                        <span class="comment">// 更新路径数组</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">1</span>; h &lt; i; h++) &#123;</span><br><span class="line">                            path[i][j][h] = path[i - <span class="number">1</span>][j - k][h];</span><br><span class="line">                        &#125;</span><br><span class="line">                        path[i][j][i] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出最大盈利值</span></span><br><span class="line">    cout &lt;&lt; dp[N][M] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出每个公司分配的设备数</span></span><br><span class="line">    <span class="type">int</span> remaining = M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; path[N][remaining][i] &lt;&lt; endl;</span><br><span class="line">        remaining -= path[N][remaining][i]; <span class="comment">// 更新剩余设备数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子串-1"><a href="#最长回文子串-1" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">// 初始化二维数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 单字符回文</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        f[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">1</span>;  <span class="comment">// 最长回文子串的长度</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;       <span class="comment">// 最长回文子串的起始位置</span></span><br><span class="line">    <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123; <span class="comment">// 子串长度从 2 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>; <span class="comment">// 子串的右边界</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">2</span> || f[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    f[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (len &gt; maxlen) &#123;</span><br><span class="line">                        maxlen = len;</span><br><span class="line">                        l = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(l, maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最长回文子串-马拉车算法"><a href="#最长回文子串-马拉车算法" class="headerlink" title="最长回文子串(马拉车算法)"></a>最长回文子串(马拉车算法)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预处理</span></span><br><span class="line">	string s1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">		s1 += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">		s1 += s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	s1 += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">	len = s<span class="number">1.l</span>ength();</span><br><span class="line">	<span class="type">int</span> MaxRight = <span class="number">0</span>;				<span class="comment">// 当前访问到的所有回文子串，所能触及的最右一个字符的位置</span></span><br><span class="line">	<span class="type">int</span> pos = <span class="number">0</span>;					<span class="comment">// MaxRight对应的回文串的对称轴所在的位置</span></span><br><span class="line">	<span class="type">int</span> MaxRL = <span class="number">0</span>;					<span class="comment">// 最大回文串的回文半径</span></span><br><span class="line">	<span class="type">int</span> MaxPos = <span class="number">0</span>;					<span class="comment">// MaxRL对应的回文串的对称轴所在的位置</span></span><br><span class="line">	<span class="type">int</span>* RL = <span class="keyword">new</span> <span class="type">int</span>[len];			<span class="comment">// RL[i]表示以第i个字符为对称轴的回文串的回文半径</span></span><br><span class="line">	<span class="built_in">memset</span>(RL, <span class="number">0</span>, len * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; MaxRight)&#123;<span class="comment">// 1) 当i在MaxRight的左边</span></span><br><span class="line">			RL[i] = <span class="built_in">min</span>(RL[<span class="number">2</span> * pos - i], MaxRight - i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">// 2) 当i在MaxRight的右边</span></span><br><span class="line">			RL[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 尝试扩展RL[i]，注意处理边界</span></span><br><span class="line">		<span class="keyword">while</span> (i - RL[i] &gt;= <span class="number">0</span>  <span class="comment">// 可以把RL[i]理解为左半径,即回文串的起始位不能小于0</span></span><br><span class="line">			&amp;&amp; i + RL[i] &lt; len <span class="comment">// 同上,即回文串的结束位不能大于总长</span></span><br><span class="line">			&amp;&amp; s1[i - RL[i]] == s1[i + RL[i]]<span class="comment">// 回文串特性，左右扩展，判断字符串是否相同</span></span><br><span class="line">			)</span><br><span class="line">        &#123;</span><br><span class="line">			RL[i] += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 更新MaxRight, pos</span></span><br><span class="line">		<span class="keyword">if</span> (RL[i] + i - <span class="number">1</span> &gt; MaxRight)&#123;</span><br><span class="line">			MaxRight = RL[i] + i - <span class="number">1</span>;</span><br><span class="line">			pos = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 更新MaxRL, MaxPos</span></span><br><span class="line">		<span class="keyword">if</span> (MaxRL &lt;= RL[i])&#123;</span><br><span class="line">			MaxRL = RL[i];</span><br><span class="line">			MaxPos = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>((MaxPos - MaxRL + <span class="number">1</span>) / <span class="number">2</span>, MaxRL - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxx=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> minn=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> ans=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp=maxx;</span><br><span class="line">        maxx=<span class="built_in">max</span>(<span class="built_in">max</span>(maxx*nums[i],nums[i]),minn*nums[i]);</span><br><span class="line">        minn=<span class="built_in">min</span>(<span class="built_in">min</span>(minn*nums[i],nums[i]),tmp*nums[i]);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,maxx);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="涂色，k种颜色，且同颜色最多连续两个"><a href="#涂色，k种颜色，且同颜色最多连续两个" class="headerlink" title="涂色，k种颜色，且同颜色最多连续两个"></a>涂色，k种颜色，且同颜色最多连续两个</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> k*k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>]=k;</span><br><span class="line">    f[<span class="number">2</span>]=k*k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i]=(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])*(k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="双序列配对-从最小-大的元素开始贪心"><a href="#双序列配对-从最小-大的元素开始贪心" class="headerlink" title="双序列配对(从最小&#x2F;大的元素开始贪心)"></a>双序列配对(从最小&#x2F;大的元素开始贪心)</h3><h4 id="田忌赛马"><a href="#田忌赛马" class="headerlink" title="田忌赛马"></a>田忌赛马</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">advantageCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">    ranges::<span class="built_in">sort</span>(nums1);</span><br><span class="line">    <span class="type">int</span> n = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ids</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(ids.<span class="built_in">begin</span>(), ids.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    ranges::<span class="built_in">sort</span>(ids, [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123; <span class="keyword">return</span> nums2[i] &lt; nums2[j]; &#125;);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums1) &#123;</span><br><span class="line">        ans[x &gt; nums2[ids[left]] ? ids[left++] : ids[right--]] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p><strong>注意，要看清题目存储点是从下标0还是1开始，根据具体情况改代码</strong></p>
<h3 id="邻接矩阵存储-DFS，BFS，拓扑排序，Prim，Floyd，Bellman-Ford，Dijkstra"><a href="#邻接矩阵存储-DFS，BFS，拓扑排序，Prim，Floyd，Bellman-Ford，Dijkstra" class="headerlink" title="邻接矩阵存储(DFS，BFS，拓扑排序，Prim，Floyd，Bellman-Ford，Dijkstra)"></a>邻接矩阵存储(DFS，BFS，拓扑排序，Prim，Floyd，Bellman-Ford，Dijkstra)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_NODES=<span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjMatrix[MAX_NODES][MAX_NODES];</span><br><span class="line">    <span class="type">int</span> numNodes;</span><br><span class="line">    <span class="type">bool</span> visited[MAX_NODES];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        numNodes=n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numNodes; j++) &#123;</span><br><span class="line">                adjMatrix[i][j] = (i == j) ? <span class="number">0</span> : INF; <span class="comment">// 初始化为无穷大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">        adjMatrix[u][v]=w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dfs遍历图节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adjMatrix[node][i] != INF &amp;&amp; !visited[i]) &#123; <span class="comment">// 检查有边且未访问</span></span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除访问状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetVisited</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="built_in">sizeof</span>(visited));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bfs</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(numNodes, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        visited[start] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (adjMatrix[v][i] != INF &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                    visited[i] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//拓扑排序(kahn)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numNodes, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每个节点的入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numNodes; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (adjMatrix[i][j] != INF &amp;&amp; adjMatrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    inDegree[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将入度为0的节点加入队列</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; topoOrder; <span class="comment">// 存储拓扑排序结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行拓扑排序</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            topoOrder.<span class="built_in">push_back</span>(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前节点的邻接节点的入度减1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (adjMatrix[node][i] != INF &amp;&amp; adjMatrix[node][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    inDegree[i]--;</span><br><span class="line">                    <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否存在环</span></span><br><span class="line">        <span class="keyword">if</span> (topoOrder.<span class="built_in">size</span>() != numNodes) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出拓扑排序结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> node : topoOrder) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prim最小生成树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">primMST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">key</span><span class="params">(numNodes, INF)</span></span>; <span class="comment">// 节点的权值</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inMST</span><span class="params">(numNodes, <span class="literal">false</span>)</span></span>; <span class="comment">// 节点是否在MST中</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(numNodes, <span class="number">-1</span>)</span></span>; <span class="comment">// 用于存储最小生成树</span></span><br><span class="line"></span><br><span class="line">        key[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 从第一个节点开始</span></span><br><span class="line">        parent[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 根节点没有父节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 找到未包含在MST中的权值最小的节点</span></span><br><span class="line">            <span class="type">int</span> minKey = INF, u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; numNodes; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!inMST[v] &amp;&amp; key[v] &lt; minKey) &#123;</span><br><span class="line">                    minKey = key[v];</span><br><span class="line">                    u = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将选定的节点加入MST</span></span><br><span class="line">            inMST[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新该节点的邻接节点的权值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; numNodes; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (adjMatrix[u][v] != INF &amp;&amp; !inMST[v] &amp;&amp; adjMatrix[u][v] &lt; key[v]) &#123;</span><br><span class="line">                    key[v] = adjMatrix[u][v];</span><br><span class="line">                    parent[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最小生成树的边和权重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Edge &quot;</span> &lt;&lt; parent[i] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; Weight: &quot;</span> &lt;&lt; adjMatrix[i][parent[i]] &lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//floyd最短路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">floydShortestPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(numNodes, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(numNodes, INF));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化距离矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numNodes; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (adjMatrix[i][j] != INF) &#123;</span><br><span class="line">                    dist[i][j] = adjMatrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Floyd-Warshall算法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; numNodes; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numNodes; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] != INF &amp;&amp; dist[k][j] != INF) &#123;</span><br><span class="line">                        dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最短路径矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numNodes; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][j] == INF) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;INF &quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    cout &lt;&lt; dist[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Bellman-Ford算法</span></span><br><span class="line">    <span class="comment">//src是起点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bellmanFord</span><span class="params">(<span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(numNodes, INF)</span></span>;</span><br><span class="line">        distance[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 松弛操作：重复 V-1 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numNodes - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; numNodes; u++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; numNodes; v++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (adjMatrix[u][v] != INF &amp;&amp; distance[u] != INF &amp;&amp; distance[u] + adjMatrix[u][v] &lt; distance[v]) &#123;</span><br><span class="line">                        distance[v] = distance[u] + adjMatrix[u][v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测负环：如果在第 V 次松弛后还能更新距离，则存在负环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; numNodes; u++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; numNodes; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (adjMatrix[u][v] != INF &amp;&amp; distance[u] != INF &amp;&amp; distance[u] + adjMatrix[u][v] &lt; distance[v]) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;图中存在负环，无法计算最短路径。&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最短路径结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[i] == INF) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;到节点 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 无法到达&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;到节点 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 的最短距离是 &quot;</span> &lt;&lt; distance[i] &lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dijkstra算法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(numNodes, INF)</span></span>; <span class="comment">// 存储最短距离</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(numNodes, <span class="literal">false</span>)</span></span>; <span class="comment">// 标记节点是否已访问</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(numNodes, <span class="number">-1</span>)</span></span>; <span class="comment">// 存储最短路径的前驱节点</span></span><br><span class="line"></span><br><span class="line">        distance[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 找到未访问的节点中距离源节点最近的节点</span></span><br><span class="line">            <span class="type">int</span> minDist = INF, u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; numNodes; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; distance[v] &lt; minDist) &#123;</span><br><span class="line">                    minDist = distance[v];</span><br><span class="line">                    u = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新邻接节点的距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; numNodes; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; adjMatrix[u][v] != INF &amp;&amp; distance[u] != INF &amp;&amp;</span><br><span class="line">                    distance[u] + adjMatrix[u][v] &lt; distance[v]) &#123;</span><br><span class="line">                    distance[v] = distance[u] + adjMatrix[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出从src节点到其他节点的最短距离</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;从节点 &quot;</span> &lt;&lt; src &lt;&lt; <span class="string">&quot; 到其他节点的最短路径距离：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[i] == INF) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;到节点 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 无法到达&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;到节点 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 的最短距离是 &quot;</span> &lt;&lt; distance[i] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graph g;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">    g.<span class="built_in">init</span>(n);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DFS Traversal from node 0: &quot;</span>);</span><br><span class="line">    g.<span class="built_in">resetVisited</span>(); <span class="comment">// Reset visited array</span></span><br><span class="line">    g.<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BFS Traversal from node 0: &quot;</span>);</span><br><span class="line">    g.<span class="built_in">bfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Topological Sort (Kahn&#x27;s Algorithm): &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g.<span class="built_in">topologicalSort</span>()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The graph has a cycle.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Prim&#x27;s Minimum Spanning Tree:\n&quot;</span>);</span><br><span class="line">    g.<span class="built_in">primMST</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Floyd-Warshall Shortest Path:\n&quot;</span>);</span><br><span class="line">    g.<span class="built_in">floydShortestPath</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bellman-Ford Shortest Path from node 0:\n&quot;</span>);</span><br><span class="line">    g.<span class="built_in">bellmanFord</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dijkstra&#x27;s Shortest Path from node 0:\n&quot;</span>);</span><br><span class="line">    g.<span class="built_in">dijkstra</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="邻接表存储-DFS，BFS，拓扑排序，Kruskal，Floyd，Bellman-Ford，Dijkstra"><a href="#邻接表存储-DFS，BFS，拓扑排序，Kruskal，Floyd，Bellman-Ford，Dijkstra" class="headerlink" title="邻接表存储(DFS，BFS，拓扑排序，Kruskal，Floyd，Bellman-Ford，Dijkstra)"></a>邻接表存储(DFS，BFS，拓扑排序，Kruskal，Floyd，Bellman-Ford，Dijkstra)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_NODES = <span class="number">100001</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; adjList[MAX_NODES]; <span class="comment">// 邻接表，存储的是边和权重</span></span><br><span class="line">    <span class="type">int</span> numNodes;</span><br><span class="line">    <span class="type">bool</span> visited[MAX_NODES];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        numNodes = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            adjList[i].<span class="built_in">clear</span>(); <span class="comment">// 清除邻接表的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加边</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        adjList[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DFS 遍历图节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : adjList[node]) &#123;</span><br><span class="line">            <span class="type">int</span> neighbor = edge.first;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除访问状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetVisited</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="built_in">sizeof</span>(visited));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(numNodes, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        visited[start] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : adjList[v]) &#123;</span><br><span class="line">                <span class="type">int</span> neighbor = edge.first;</span><br><span class="line">                <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓扑排序 (Kahn 算法)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numNodes, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每个节点的入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : adjList[i]) &#123;</span><br><span class="line">                <span class="type">int</span> v = edge.first;</span><br><span class="line">                inDegree[v]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将入度为 0 的节点加入队列</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; topoOrder; <span class="comment">// 存储拓扑排序结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行拓扑排序</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            topoOrder.<span class="built_in">push_back</span>(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前节点的邻接节点的入度减 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : adjList[node]) &#123;</span><br><span class="line">                <span class="type">int</span> v = edge.first;</span><br><span class="line">                inDegree[v]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否存在环</span></span><br><span class="line">        <span class="keyword">if</span> (topoOrder.<span class="built_in">size</span>() != numNodes) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出拓扑排序结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> node : topoOrder) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------Kruskal---------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并查集</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[i] == <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(parent, parent[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并并查集</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xroot = <span class="built_in">find</span>(parent, x);</span><br><span class="line">        <span class="type">int</span> yroot = <span class="built_in">find</span>(parent, y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xroot != yroot) &#123;</span><br><span class="line">            parent[xroot] = yroot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kruskal 算法求最小生成树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">kruskalMST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; edges; <span class="comment">// 存储边 (权重, (u, v))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把所有边放入边列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; numNodes; u++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; neighbor : adjList[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v = neighbor.first;</span><br><span class="line">                <span class="type">int</span> w = neighbor.second;</span><br><span class="line">                <span class="keyword">if</span> (u &lt; v) &#123; <span class="comment">// 防止重复加入无向图的边</span></span><br><span class="line">                    edges.<span class="built_in">push_back</span>(&#123;w, &#123;u, v&#125;&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照边的权重升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> parent[numNodes];</span><br><span class="line">        <span class="built_in">fill</span>(parent, parent + numNodes, <span class="number">-1</span>); <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; mst; <span class="comment">// 存储最小生成树的边</span></span><br><span class="line">        <span class="type">int</span> mstWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个遍历边，按权重从小到大选边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> u = edge.second.first;</span><br><span class="line">            <span class="type">int</span> v = edge.second.second;</span><br><span class="line">            <span class="type">int</span> weight = edge.first;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">find</span>(parent, u);</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">find</span>(parent, v);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123; <span class="comment">// 如果u和v不在同一个集合，加入最小生成树</span></span><br><span class="line">                mst.<span class="built_in">push_back</span>(&#123;u, v&#125;);</span><br><span class="line">                mstWeight += weight;</span><br><span class="line">                <span class="built_in">Union</span>(parent, x, y); <span class="comment">// 合并u和v的集合</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最小生成树</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;最小生成树的边及其权重:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : mst) &#123;</span><br><span class="line">            cout &lt;&lt; edge.first &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; edge.second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;最小生成树的总权重: &quot;</span> &lt;&lt; mstWeight &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Floyd 最短路径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">floydShortestPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(numNodes, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(numNodes, INF));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化距离矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : adjList[i]) &#123;</span><br><span class="line">                <span class="type">int</span> v = edge.first;</span><br><span class="line">                dist[i][v] = edge.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Floyd-Warshall 算法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; numNodes; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numNodes; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] != INF &amp;&amp; dist[k][j] != INF) &#123;</span><br><span class="line">                        dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最短路径矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numNodes; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][j] == INF) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;INF &quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cout &lt;&lt; dist[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bellman-Ford 算法</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bellmanFord</span><span class="params">(<span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(numNodes, INF)</span></span>;</span><br><span class="line">        distance[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 松弛操作：重复 V-1 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numNodes - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; numNodes; u++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : adjList[u]) &#123;</span><br><span class="line">                    <span class="type">int</span> v = edge.first;</span><br><span class="line">                    <span class="type">int</span> w = edge.second;</span><br><span class="line">                    <span class="keyword">if</span> (distance[u] != INF &amp;&amp; distance[u] + w &lt; distance[v]) &#123;</span><br><span class="line">                        distance[v] = distance[u] + w;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测负环：如果在第 V 次松弛后还能更新距离，则存在负环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; numNodes; u++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : adjList[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v = edge.first;</span><br><span class="line">                <span class="type">int</span> w = edge.second;</span><br><span class="line">                <span class="keyword">if</span> (distance[u] != INF &amp;&amp; distance[u] + w &lt; distance[v]) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;图中存在负环，无法计算最短路径。&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最短路径结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[i] == INF) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;到节点 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 无法到达&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;到节点 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 的最短距离是 &quot;</span> &lt;&lt; distance[i] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dijkstra 算法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(numNodes, INF)</span></span>; <span class="comment">// 存储最短距离</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(numNodes, <span class="literal">false</span>)</span></span>; <span class="comment">// 标记节点是否已访问</span></span><br><span class="line"></span><br><span class="line">        distance[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 找到未访问的节点中距离源节点最近的节点</span></span><br><span class="line">            <span class="type">int</span> minDist = INF, u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; numNodes; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; distance[v] &lt; minDist) &#123;</span><br><span class="line">                    minDist = distance[v];</span><br><span class="line">                    u = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新邻接节点的距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : adjList[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v = edge.first;</span><br><span class="line">                <span class="type">int</span> w = edge.second;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; distance[u] + w &lt; distance[v]) &#123;</span><br><span class="line">                    distance[v] = distance[u] + w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出从 src 节点到其他节点的最短距离</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;从节点 &quot;</span> &lt;&lt; src &lt;&lt; <span class="string">&quot; 到其他节点的最短距离：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[i] == INF) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;到节点 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 无法到达&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;到节点 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 的最短距离是 &quot;</span> &lt;&lt; distance[i] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graph g;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// 图的节点数量</span></span><br><span class="line">    g.<span class="built_in">init</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一些边</span></span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DFS遍历图&quot;</span> &lt;&lt; endl;</span><br><span class="line">    g.<span class="built_in">resetVisited</span>();</span><br><span class="line">    g.<span class="built_in">dfs</span>(<span class="number">0</span>); <span class="comment">// 从节点0开始DFS遍历</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BFS遍历图&quot;</span> &lt;&lt; endl;</span><br><span class="line">    g.<span class="built_in">bfs</span>(<span class="number">0</span>); <span class="comment">// 从节点0开始BFS遍历</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拓扑排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (!g.<span class="built_in">topologicalSort</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;图中有环，无法进行拓扑排序！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Floyd最短路径&quot;</span> &lt;&lt; endl;</span><br><span class="line">    g.<span class="built_in">floydShortestPath</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bellman-Ford最短路径&quot;</span> &lt;&lt; endl;</span><br><span class="line">    g.<span class="built_in">bellmanFord</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Dijkstra最短路径&quot;</span> &lt;&lt; endl;</span><br><span class="line">    g.<span class="built_in">dijkstra</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集可以判断：两个元素是否在同一个集合中、添加一条边到图中是否成环，图的连通分量。<br>在Kruskal算法中，因为每次要选最小的但是添加进去不会成环的边，所以用并查集做判断。</p>
<h4 id="无优化"><a href="#无优化" class="headerlink" title="无优化"></a>无优化</h4><p>判断图是否是树(即：是否正好有n-1条边，并且没有环)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (A != parent[A]) &#123;</span><br><span class="line">            A = parent[A];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> root_A = <span class="built_in">find</span>(A);</span><br><span class="line">        <span class="type">int</span> root_B = <span class="built_in">find</span>(B);</span><br><span class="line">        <span class="keyword">if</span> (root_A == root_B) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[root_A] = root_B;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (edges.<span class="built_in">size</span>() != n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">UnionFind <span class="title">unionFind</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!unionFind.<span class="built_in">unionSets</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="路径压缩-与-按秩合并-优化"><a href="#路径压缩-与-按秩合并-优化" class="headerlink" title="路径压缩 与 按秩合并 优化"></a>路径压缩 与 按秩合并 优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n) : <span class="built_in">parent</span>(n), <span class="built_in">size</span>(n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> root = A;</span><br><span class="line">        <span class="keyword">while</span> (root != parent[root]) &#123;</span><br><span class="line">            root = parent[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (A != root) &#123;</span><br><span class="line">            <span class="type">int</span> oldRoot = parent[A];</span><br><span class="line">            parent[A] = root;</span><br><span class="line">            A = oldRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unionSets</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rootA = <span class="built_in">find</span>(A);</span><br><span class="line">        <span class="type">int</span> rootB = <span class="built_in">find</span>(B);</span><br><span class="line">        <span class="keyword">if</span> (rootA == rootB) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size[rootA] &lt; size[rootB]) &#123;</span><br><span class="line">            parent[rootA] = rootB;</span><br><span class="line">            size[rootB] += size[rootA];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootB] = rootA;</span><br><span class="line">            size[rootA] += size[rootB];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (edges.<span class="built_in">size</span>() != n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">UnionFind <span class="title">unionFind</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!unionFind.<span class="built_in">unionSets</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> s, t;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">1e5</span> + <span class="number">5</span>; <span class="comment">// 表示点数和边数的上限。视具体情况而定 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> ne;         <span class="comment">// next</span></span><br><span class="line">	<span class="type">int</span> v;      <span class="comment">// to 表示当前边到达的点，ne 表示下一条边的下标，相当于链表指针，v 表示剩余容量。</span></span><br><span class="line">&#125; ed[M];    </span><br><span class="line"><span class="comment">// dinic算法中一般用链式前向心的方式存储边，简单来说就是给每个点开一个 链表 存储出边</span></span><br><span class="line"><span class="type">int</span> head[N];        <span class="comment">// 链式前向心中的头指针数组</span></span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;<span class="comment">//当前已经使用的边的数量</span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//层</span></span><br><span class="line"><span class="comment">// int fr[N];</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> to, <span class="type">int</span> v)</span> </span>&#123;  <span class="comment">// 链式前向心的加边操作，和链表添加类似</span></span><br><span class="line">    <span class="comment">// 添加一条从f到to，容量为v的边</span></span><br><span class="line">	<span class="comment">//head[f]是这条边起点f的第一条边</span></span><br><span class="line">	ed[++p].to = to, ed[p].ne = head[f], head[f] = p, ed[p].v = v;     <span class="comment">// 正向边，剩余容量为v</span></span><br><span class="line">	ed[++p].to = f, ed[p].ne = head[to], head[to] = p, ed[p].v = <span class="number">0</span>;    <span class="comment">// 最大流算法中的反向边，初始容量为0</span></span><br><span class="line">&#125;       </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;            <span class="comment">// dinic算法每轮先通过bfs进行分层</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) d[i] = <span class="number">-1</span>; <span class="comment">// d[i] 表示节点 i 位于第几层。初值为-1</span></span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span> (s);</span><br><span class="line">	d[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// fr[s] = head[s];</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = ed[i].ne) &#123;  <span class="comment">// 跳转链表的方式遍历所有边</span></span><br><span class="line">			<span class="type">int</span> to = ed[i].to;</span><br><span class="line">			<span class="keyword">if</span> (d[to] == <span class="number">-1</span> &amp;&amp; ed[i].v) &#123;      <span class="comment">// 如果to尚未遍历且这条边还有容量，进行遍历</span></span><br><span class="line">				d[to] = d[x] + <span class="number">1</span>;</span><br><span class="line">				<span class="comment">// fr[to] = head[to];</span></span><br><span class="line">				q.<span class="built_in">push</span>(to);</span><br><span class="line">				<span class="keyword">if</span> (to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>);     <span class="comment">// 定义一个表示“无穷大”的常量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> flow)</span> </span>&#123;        <span class="comment">// 当前走到now，之前得到的最大流通量为flow</span></span><br><span class="line">	<span class="keyword">if</span> (now == t) <span class="keyword">return</span> flow;      <span class="comment">// 寻找通路的递归边界</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[now]; i &amp;&amp; res &lt; flow; i = ed[i].ne) &#123;  </span><br><span class="line">		<span class="type">int</span> to = ed[i].to;</span><br><span class="line">		<span class="comment">// fr[r] = i;</span></span><br><span class="line">		<span class="keyword">if</span> (ed[i].v == <span class="number">0</span> || d[to] != d[now] + <span class="number">1</span>) <span class="keyword">continue</span>;  <span class="comment">// 无剩余容量或不满足分层图中的关系</span></span><br><span class="line">		<span class="type">int</span> get = <span class="built_in">dfs</span> (to, <span class="built_in">min</span> (flow - res, ed[i].v));   <span class="comment">// 递归计算这一条边走下去最多能流通多少流量</span></span><br><span class="line">		<span class="keyword">if</span> (get == <span class="number">0</span>) d[to] = <span class="number">-1</span>;       <span class="comment">// 如果留不通，标记为-1，下次就不会走了</span></span><br><span class="line">		ed[i].v -= get;</span><br><span class="line">		ed[i ^ <span class="number">1</span>].v += get;         <span class="comment">// 正边流量减少；反边增加，用于“反悔”操作</span></span><br><span class="line">		<span class="comment">//i^1:异或运算，相当于i+1，i为奇数时，i+1为偶数，i为偶数时，i+1为奇数</span></span><br><span class="line">		res += get;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = fr[r]; i &amp;&amp; res &lt; flow; i = ed[i].ne)  </span></span><br><span class="line"><span class="comment">        利用 fr 数组的优化（当前弧优化），减少循环次数。此模板暂不提及</span></span><br><span class="line"><span class="comment">        代码里关于fr数组的其它内容也已经注释</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> tem = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">		<span class="keyword">while</span> (tem = <span class="built_in">dfs</span> (s, inf))     <span class="comment">// 初始时流通量记为inf，给后面的搜索足够的“发挥空间”</span></span><br><span class="line">			ans += tem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld %lld %lld %lld&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">	p = <span class="number">1</span>;          <span class="comment">// 重置边的计数器</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) head[i] = <span class="number">0</span>;  <span class="comment">// 重置每个链表的表头</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x, y, z; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%lld %lld %lld&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">		<span class="built_in">add</span> (x, y, z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="built_in">dinic</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">sol</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="另一个dinic"><a href="#另一个dinic" class="headerlink" title="另一个dinic"></a>另一个dinic</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 2147483647</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> graph[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line">map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; &gt; last;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> re[<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> depth[<span class="number">510</span>];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">path</span><span class="params">(<span class="number">510</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> cur[<span class="number">1010</span>]; <span class="comment">// 当前弧数组</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0</span>, <span class="built_in">sizeof</span>(depth));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(i);</span><br><span class="line">    depth[i] = <span class="number">1</span>;</span><br><span class="line">    cur[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt;::iterator iter;</span><br><span class="line">        <span class="keyword">for</span> (iter = last[x].<span class="built_in">begin</span>(); iter != last[x].<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((!depth[iter-&gt;first]) &amp;&amp; (iter-&gt;second &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(iter-&gt;first);</span><br><span class="line">                depth[iter-&gt;first] = depth[x] + <span class="number">1</span>;</span><br><span class="line">                cur[iter-&gt;first] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;first == t)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t, <span class="type">long</span> <span class="type">long</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t)&#123;</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid = limit;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt;::iterator iter = last[u].<span class="built_in">begin</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从cur[u]位置开始遍历</span></span><br><span class="line">    <span class="built_in">advance</span>(iter, cur[u]); <span class="comment">// 将iter移到cur[u]位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; iter != last[u].<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;second &gt; <span class="number">0</span> &amp;&amp; depth[iter-&gt;first] == depth[u] + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> tmp = <span class="built_in">dfs</span>(iter-&gt;first, t, <span class="built_in">min</span>(mid, iter-&gt;second));</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                depth[iter-&gt;first] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid -= tmp;</span><br><span class="line">            iter-&gt;second -= tmp;         <span class="comment">// 可流出量减少</span></span><br><span class="line">            last[iter-&gt;first][u] += tmp; <span class="comment">// 反向边增加</span></span><br><span class="line">            <span class="keyword">if</span> (mid &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur[u]++; <span class="comment">// 当前弧优化，表示对于节点u我们已经遍历到了第cur[u]条边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> limit - mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dinic</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>(s, t))&#123;</span><br><span class="line">        ans += <span class="built_in">dfs</span>(s, t, MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    s = <span class="number">1</span>;</span><br><span class="line">    t = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            graph[i][j] = <span class="number">0</span>;</span><br><span class="line">            last[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        re[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span> (u == v)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        w = <span class="number">1</span>;</span><br><span class="line">        graph[u][v] += w;</span><br><span class="line">        last[u][v] += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dinic</span>(n, s, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dinic-from-助教"><a href="#Dinic-from-助教" class="headerlink" title="Dinic from 助教"></a>Dinic from 助教</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> E = <span class="number">2005</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line"><span class="type">int</span> h[N], to[E], nx[E], et;</span><br><span class="line"><span class="type">int</span> cap[E], flow[E];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ae</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	et++;</span><br><span class="line">	to[et] = v;</span><br><span class="line">	nx[et] = h[u];</span><br><span class="line">	cap[et] = w;</span><br><span class="line">	flow[et] = <span class="number">0</span>;</span><br><span class="line">	h[u] = et;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> S, T, d[N], q[N], cur[N], ql, qr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d[i] = <span class="number">0</span>;</span><br><span class="line">		cur[i] = h[i];</span><br><span class="line">	&#125;</span><br><span class="line">	d[S] = <span class="number">1</span>;</span><br><span class="line">	ql = <span class="number">1</span>; qr = <span class="number">0</span>;</span><br><span class="line">	q[++qr] = S;</span><br><span class="line">	<span class="keyword">while</span> (ql &lt;= qr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = q[ql++];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i; i = nx[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (d[to[i]] || cap[i] == flow[i])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			d[to[i]] = d[u] + <span class="number">1</span>;</span><br><span class="line">			q[++qr] = to[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> mx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == T || mx == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> mx;</span><br><span class="line">	<span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; cur[u]; cur[u] = nx[cur[u]])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i = cur[u];</span><br><span class="line">		<span class="keyword">if</span> (d[to[i]] != d[u] + <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> v = <span class="built_in">dfs</span>(to[i], <span class="built_in">min</span>(mx, cap[i] - flow[i]));</span><br><span class="line">		flow[i] += v;</span><br><span class="line">		flow[i ^ <span class="number">1</span>] -= v;</span><br><span class="line">		r += v;</span><br><span class="line">		mx -= v;</span><br><span class="line">		<span class="keyword">if</span> (mx == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	d[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxflow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	S = s; T = t;</span><br><span class="line">	<span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">bfs</span>()) r += <span class="built_in">dfs</span>(s, <span class="number">1e9</span>);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	s = <span class="number">1</span>; t = n;</span><br><span class="line">	et = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">		<span class="built_in">ae</span>(u, v, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">ae</span>(v, u, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">maxflow</span>(s, t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// scanf(&quot;%d&quot;, &amp;T);</span></span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="二分图的判定"><a href="#二分图的判定" class="headerlink" title="二分图的判定"></a>二分图的判定</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">color</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 0表示未染色，1表示染成红色，-1表示染成蓝色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">0</span>) &#123; <span class="comment">// 如果这个点没有染色</span></span><br><span class="line">            queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">            color[i] = <span class="number">1</span>; <span class="comment">// 染成红色</span></span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : graph[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (color[v] == <span class="number">0</span>) &#123; <span class="comment">// 如果这个点没有染色</span></span><br><span class="line">                        color[v] = -color[u]; <span class="comment">// 染成与u不同的颜色</span></span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[v] == color[u]) &#123; <span class="comment">// 如果这个点已经染色，并且颜色与u相同</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不是二分图</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 是二分图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无权最大匹配-匈牙利算法"><a href="#无权最大匹配-匈牙利算法" class="headerlink" title="无权最大匹配(匈牙利算法)"></a>无权最大匹配(匈牙利算法)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//match：右集合中每个节点当前匹配的左集合节点</span></span><br><span class="line"><span class="comment">//st: 标记数组，用来记录 右集合中的节点是否已被访问过，用于防止重复遍历。</span></span><br><span class="line"><span class="comment">//find：为左集合中的节点 x 寻找一个增广路径，从而 找到一个新的匹配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line"><span class="comment">//const int N = 1e6 + 10;</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt; adj[510];  // 邻接表，用vector存储每个节点的邻接边</span></span><br><span class="line"><span class="type">int</span> match[<span class="number">510</span>];        <span class="comment">// 存储匹配的右侧节点</span></span><br><span class="line"><span class="type">bool</span> st[<span class="number">510</span>];          <span class="comment">// 标记右侧节点是否已经被访问过</span></span><br><span class="line"><span class="comment">// 向邻接表中添加边</span></span><br><span class="line"><span class="comment">// void add(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">//     adj[a].push_back(b);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 尝试为节点 x 寻找增广路</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : g[x]) &#123;  <span class="comment">// 遍历节点 x 的所有邻接边</span></span><br><span class="line">        <span class="keyword">if</span> (!st[t]) &#123;  <span class="comment">// 如果右侧节点 t 没有被访问过</span></span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果 t 没有匹配的节点，或者通过增广路找到可以匹配的节点</span></span><br><span class="line">            <span class="keyword">if</span> (match[t] == <span class="number">-1</span> || <span class="built_in">find</span>(match[t])) &#123;</span><br><span class="line">                match[t] = x;  <span class="comment">// 将 t 匹配到 x</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">/*在这里输入图g*/</span>   </span><br><span class="line">    <span class="built_in">memset</span>(match , <span class="number">-1</span>, <span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对每个左侧节点 i 尝试寻找增广路</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);  <span class="comment">// 每次寻找增广路时，清空访问标记</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res++;  <span class="comment">// 如果找到增广路，增加匹配数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;  <span class="comment">// 输出最大匹配数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="带权二分图的最小权匹配"><a href="#带权二分图的最小权匹配" class="headerlink" title="带权二分图的最小权匹配"></a>带权二分图的最小权匹配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h3 id="垂线段"><a href="#垂线段" class="headerlink" title="垂线段"></a>垂线段</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//欧几里得距离</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">distance</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两向量的点积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1 * x2 + y1 * y2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量的长度（模）</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t; </span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">double</span> xA, yA, xP, yP, xQ, yQ;</span><br><span class="line">        <span class="comment">// 输入点 A 的坐标</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;xA, &amp;yA);</span><br><span class="line">        <span class="comment">// 输入线段 PQ 的两个端点 P 和 Q 的坐标</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;xP, &amp;yP, &amp;xQ, &amp;yQ);</span><br><span class="line">        <span class="comment">// 计算向量 PQ 和 PA</span></span><br><span class="line">        <span class="type">double</span> pqX = xQ - xP; <span class="comment">// 向量 PQ 的 x 分量</span></span><br><span class="line">        <span class="type">double</span> pqY = yQ - yP; <span class="comment">// 向量 PQ 的 y 分量</span></span><br><span class="line">        <span class="type">double</span> paX = xA - xP; <span class="comment">// 向量 PA 的 x 分量</span></span><br><span class="line">        <span class="type">double</span> paY = yA - yP; <span class="comment">// 向量 PA 的 y 分量</span></span><br><span class="line">        <span class="comment">// 计算线段 PQ 的长度平方（避免重复开方运算，提高效率）</span></span><br><span class="line">        <span class="type">double</span> pqLengthSquared = pqX * pqX + pqY * pqY;</span><br><span class="line">        <span class="comment">// 计算点 A 在直线 PQ 上的投影比例 t</span></span><br><span class="line">        <span class="comment">// t = (PA向量与PQ向量的点积) / (PQ向量的长度平方)</span></span><br><span class="line">        <span class="type">double</span> t = (paX * pqX + paY * pqY) / pqLengthSquared;</span><br><span class="line">        <span class="type">double</span> minDist; <span class="comment">// 最短距离</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 投影点在 P 外，最近点为 P</span></span><br><span class="line">            minDist = <span class="built_in">distance</span>(xA, yA, xP, yP);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 投影点在 Q 外，最近点为 Q</span></span><br><span class="line">            minDist = <span class="built_in">distance</span>(xA, yA, xQ, yQ);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 投影点在线段 PQ 上，计算垂直距离</span></span><br><span class="line">            <span class="type">double</span> projX = xP + t * pqX; <span class="comment">// 投影点的 x 坐标</span></span><br><span class="line">            <span class="type">double</span> projY = yP + t * pqY; <span class="comment">// 投影点的 y 坐标</span></span><br><span class="line">            minDist = <span class="built_in">distance</span>(xA, yA, projX, projY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出最短距离，保留三位小数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, minDist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平行相交的判断"><a href="#平行相交的判断" class="headerlink" title="平行相交的判断"></a>平行相交的判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数 orientation 计算三点 p, q, r 的方向关系</span></span><br><span class="line"><span class="comment">// 返回值：</span></span><br><span class="line"><span class="comment">// 0 -&gt; 三点共线</span></span><br><span class="line"><span class="comment">// 1 -&gt; 顺时针方向</span></span><br><span class="line"><span class="comment">// 2 -&gt; 逆时针方向</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">orientation</span><span class="params">(Point p, Point q, Point r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果值为 0，三点共线</span></span><br><span class="line">    <span class="keyword">return</span> (val &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">2</span>; <span class="comment">// 大于 0 顺时针，小于 0 逆时针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数 onSegment 判断点 q 是否在线段 pr 上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onSegment</span><span class="params">(Point p, Point q, Point r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q.x &lt;= <span class="built_in">max</span>(p.x, r.x) &amp;&amp; q.x &gt;= <span class="built_in">min</span>(p.x, r.x) &amp;&amp;</span><br><span class="line">           q.y &lt;= <span class="built_in">max</span>(p.y, r.y) &amp;&amp; q.y &gt;= <span class="built_in">min</span>(p.y, r.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数 isIntersect 判断两条线段 (a, b) 和 (c, d) 是否相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isIntersect</span><span class="params">(Point a, Point b, Point c, Point d)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算四种组合的方向</span></span><br><span class="line">    <span class="type">int</span> o1 = <span class="built_in">orientation</span>(a, b, c);</span><br><span class="line">    <span class="type">int</span> o2 = <span class="built_in">orientation</span>(a, b, d);</span><br><span class="line">    <span class="type">int</span> o3 = <span class="built_in">orientation</span>(c, d, a);</span><br><span class="line">    <span class="type">int</span> o4 = <span class="built_in">orientation</span>(c, d, b);</span><br><span class="line">    <span class="comment">// 一般情况：两条线段的方向不同，说明相交</span></span><br><span class="line">    <span class="keyword">if</span> (o1 != o2 &amp;&amp; o3 != o4)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 特殊情况：线段共线，检查是否有重叠部分</span></span><br><span class="line">    <span class="keyword">if</span> (o1 == <span class="number">0</span> &amp;&amp; <span class="built_in">onSegment</span>(a, c, b)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// c 在 ab 上</span></span><br><span class="line">    <span class="keyword">if</span> (o2 == <span class="number">0</span> &amp;&amp; <span class="built_in">onSegment</span>(a, d, b)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// d 在 ab 上</span></span><br><span class="line">    <span class="keyword">if</span> (o3 == <span class="number">0</span> &amp;&amp; <span class="built_in">onSegment</span>(c, a, d)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// a 在 cd 上</span></span><br><span class="line">    <span class="keyword">if</span> (o4 == <span class="number">0</span> &amp;&amp; <span class="built_in">onSegment</span>(c, b, d)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// b 在 cd 上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 否则不相交</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数 isParallel 判断两条线段是否平行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isParallel</span><span class="params">(Point a, Point b, Point c, Point d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 平行的条件是所有点的方向关系相同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">orientation</span>(a, b, c) == <span class="built_in">orientation</span>(a, b, d) &amp;&amp; </span><br><span class="line">           <span class="built_in">orientation</span>(c, d, a) == <span class="built_in">orientation</span>(c, d, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断两条直线是否相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lineParallel</span><span class="params">(Point a, Point b, Point c, Point d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x1 = b.x - a.x;</span><br><span class="line">    <span class="type">int</span> y1 = b.y - a.y;</span><br><span class="line">    <span class="type">int</span> x2 = d.x - c.x;</span><br><span class="line">    <span class="type">int</span> y2 = d.y - c.y;</span><br><span class="line">    <span class="type">int</span> cross = x1 * y2 - x2 * y1;</span><br><span class="line">    <span class="keyword">return</span> cross == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        Point a, b, c, d; <span class="comment">// 定义四个点，表示两条线段的端点</span></span><br><span class="line">        cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y &gt;&gt; c.x &gt;&gt; c.y &gt;&gt; d.x &gt;&gt; d.y; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isIntersect</span>(a, b, c, d)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;intersect&quot;</span> &lt;&lt; endl; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isParallel</span>(a, b, c, d)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;parallel&quot;</span> &lt;&lt; endl; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;neither&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求两个线段的交点坐标"><a href="#求两个线段的交点坐标" class="headerlink" title="求两个线段的交点坐标"></a>求两个线段的交点坐标</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有交点就返回，没有就返回空vector</span></span><br><span class="line"><span class="comment">// 判断 (xk, yk) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line"><span class="comment">// 这里的前提是 (xk, yk) 一定在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inside</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> xk, <span class="type">int</span> yk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若与 x 轴平行，只需要判断 x 的部分</span></span><br><span class="line">    <span class="comment">// 若与 y 轴平行，只需要判断 y 的部分</span></span><br><span class="line">    <span class="comment">// 若为普通线段，则都要判断</span></span><br><span class="line">    <span class="keyword">return</span> (x1 == x2 || (<span class="built_in">min</span>(x1, x2) &lt;= xk &amp;&amp; xk &lt;= <span class="built_in">max</span>(x1, x2))) &amp;&amp; (y1 == y2 || (<span class="built_in">min</span>(y1, y2) &lt;= yk &amp;&amp; yk &lt;= <span class="built_in">max</span>(y1, y2)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(vector&lt;<span class="type">double</span>&gt;&amp; ans, <span class="type">double</span> xk, <span class="type">double</span> yk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将一个交点与当前 ans 中的结果进行比较</span></span><br><span class="line">    <span class="comment">// 若更优则替换</span></span><br><span class="line">    <span class="keyword">if</span> (!ans.<span class="built_in">size</span>() || xk &lt; ans[<span class="number">0</span>] || (xk == ans[<span class="number">0</span>] &amp;&amp; yk &lt; ans[<span class="number">1</span>])) &#123;</span><br><span class="line">        ans = &#123;xk, yk&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; start1, vector&lt;<span class="type">int</span>&gt;&amp; end1, vector&lt;<span class="type">int</span>&gt;&amp; start2, vector&lt;<span class="type">int</span>&gt;&amp; end2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x1 = start1[<span class="number">0</span>], y1 = start1[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> x2 = end1[<span class="number">0</span>], y2 = end1[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> x3 = start2[<span class="number">0</span>], y3 = start2[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> x4 = end2[<span class="number">0</span>], y4 = end2[<span class="number">1</span>];</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; ans;</span><br><span class="line">    <span class="comment">// 判断 (x1, y1)~(x2, y2) 和 (x3, y3)~(x4, y3) 是否平行</span></span><br><span class="line">    <span class="keyword">if</span> ((y4 - y3) * (x2 - x1) == (y2 - y1) * (x4 - x3)) &#123;</span><br><span class="line">        <span class="comment">// 若平行，则判断 (x3, y3) 是否在「直线」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">        <span class="keyword">if</span> ((y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)) &#123;</span><br><span class="line">            <span class="comment">// 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">inside</span>(x1, y1, x2, y2, x3, y3)) &#123;</span><br><span class="line">                <span class="built_in">update</span>(ans, (<span class="type">double</span>)x3, (<span class="type">double</span>)y3);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">inside</span>(x1, y1, x2, y2, x4, y4)) &#123;</span><br><span class="line">                <span class="built_in">update</span>(ans, (<span class="type">double</span>)x4, (<span class="type">double</span>)y4);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">inside</span>(x3, y3, x4, y4, x1, y1)) &#123;</span><br><span class="line">                <span class="built_in">update</span>(ans, (<span class="type">double</span>)x1, (<span class="type">double</span>)y1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">inside</span>(x3, y3, x4, y4, x2, y2)) &#123;</span><br><span class="line">                <span class="built_in">update</span>(ans, (<span class="type">double</span>)x2, (<span class="type">double</span>)y2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在平行时，其余的所有情况都不会有交点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 联立方程得到 t1 和 t2 的值</span></span><br><span class="line">        <span class="type">double</span> t1 = (<span class="type">double</span>)(x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));</span><br><span class="line">        <span class="type">double</span> t2 = (<span class="type">double</span>)(x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));</span><br><span class="line">        <span class="comment">// 判断 t1 和 t2 是否均在 [0, 1] 之间</span></span><br><span class="line">        <span class="keyword">if</span> (t1 &gt;= <span class="number">0.0</span> &amp;&amp; t1 &lt;= <span class="number">1.0</span> &amp;&amp; t2 &gt;= <span class="number">0.0</span> &amp;&amp; t2 &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">            ans = &#123;x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三点共线判断"><a href="#三点共线判断" class="headerlink" title="三点共线判断"></a>三点共线判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三点 A,B,C共线，当且仅当 向量AB×AC=0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//外积</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(point A, point B, point C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        point p[<span class="number">100005</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;p[<span class="number">0</span>].x,&amp;p[<span class="number">0</span>].y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">c</span>(p[<span class="number">0</span>], p[i], p[i<span class="number">+1</span>])!=<span class="number">0</span>)&#123;</span><br><span class="line">                res=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;how?\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;boo how! boo how!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三角形五心"><a href="#三角形五心" class="headerlink" title="三角形五心"></a>三角形五心</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 辅助函数：两点之间的中点</span></span><br><span class="line"><span class="function">point <span class="title">midpoint</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x + b.x) / <span class="number">2</span>, (a.y + b.y) / <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数：两点之间的距离</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">distance</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重心 (Centroid)：三角形顶点的平均值</span></span><br><span class="line"><span class="function">point <span class="title">centroid</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b, <span class="type">const</span> point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(a.x + b.x + c.x) / <span class="number">3</span>, (a.y + b.y + c.y) / <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 垂心 (Orthocenter)：三条高的交点</span></span><br><span class="line"><span class="function">point <span class="title">orthocenter</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b, <span class="type">const</span> point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 求出两个高的斜率并找到它们的交点</span></span><br><span class="line">    <span class="type">double</span> m1 = -(b.x - c.x) / (b.y - c.y); <span class="comment">// 高AC对应的斜率</span></span><br><span class="line">    <span class="type">double</span> m2 = -(a.x - c.x) / (a.y - c.y); <span class="comment">// 高AB对应的斜率</span></span><br><span class="line">    <span class="comment">// 高AC的直线方程：y = m1 * (x - a.x) + a.y</span></span><br><span class="line">    <span class="comment">// 高AB的直线方程：y = m2 * (x - b.x) + b.y</span></span><br><span class="line">    <span class="type">double</span> x = ((m1 * a.x - m2 * b.x) + (b.y - a.y)) / (m1 - m2);</span><br><span class="line">    <span class="type">double</span> y = m1 * (x - a.x) + a.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外心 (Circumcenter)：三角形外接圆的圆心</span></span><br><span class="line"><span class="function">point <span class="title">circumcenter</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b, <span class="type">const</span> point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中垂线1：AB的中点和垂直斜率</span></span><br><span class="line">    point midAB = <span class="built_in">midpoint</span>(a, b);</span><br><span class="line">    <span class="type">double</span> slopeAB = -(b.x - a.x) / (b.y - a.y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中垂线2：BC的中点和垂直斜率</span></span><br><span class="line">    point midBC = <span class="built_in">midpoint</span>(b, c);</span><br><span class="line">    <span class="type">double</span> slopeBC = -(c.x - b.x) / (c.y - b.y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求两条中垂线的交点</span></span><br><span class="line">    <span class="type">double</span> x = ((slopeAB * midAB.x - slopeBC * midBC.x) + (midBC.y - midAB.y)) / (slopeAB - slopeBC);</span><br><span class="line">    <span class="type">double</span> y = slopeAB * (x - midAB.x) + midAB.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找外心的另一种方法</span></span><br><span class="line"><span class="function">point <span class="title">circumcenter2</span><span class="params">(point A, point B, point C)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用行列式法计算外心</span></span><br><span class="line">    <span class="type">double</span> a1=<span class="number">2</span>*(B.x-A.x);</span><br><span class="line">    <span class="type">double</span> b1=<span class="number">2</span>*(B.y-A.y);</span><br><span class="line">    <span class="type">double</span> c1=B.x*B.x+B.y*B.y-A.x*A.x-A.y*A.y;</span><br><span class="line">    <span class="type">double</span> a2=<span class="number">2</span>*(C.x-B.x);</span><br><span class="line">    <span class="type">double</span> b2=<span class="number">2</span>*(C.y-B.y);</span><br><span class="line">    <span class="type">double</span> c2=C.x*C.x+C.y*C.y-B.x*B.x-B.y*B.y;</span><br><span class="line">    point O;</span><br><span class="line">    O.x=((c1*b2)-(c2*b1))/(a1*b2-a2*b1);</span><br><span class="line">    O.y=((a1*c2)-(a2*c1))/(a1*b2-a2*b1);</span><br><span class="line">    <span class="keyword">return</span> O;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内心 (Incenter)：三角形内切圆的圆心</span></span><br><span class="line"><span class="function">point <span class="title">incenter</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b, <span class="type">const</span> point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边的长度</span></span><br><span class="line">    <span class="type">double</span> ab = <span class="built_in">distance</span>(a, b);</span><br><span class="line">    <span class="type">double</span> bc = <span class="built_in">distance</span>(b, c);</span><br><span class="line">    <span class="type">double</span> ca = <span class="built_in">distance</span>(c, a);</span><br><span class="line">    <span class="comment">// 用边长加权平均计算内心</span></span><br><span class="line">    <span class="keyword">return</span> &#123;(ab * c.x + bc * a.x + ca * b.x) / (ab + bc + ca),</span><br><span class="line">            (ab * c.y + bc * a.y + ca * b.y) / (ab + bc + ca)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 旁心 (Excenter)：任意旁心的圆心（例如相对AB边）</span></span><br><span class="line"><span class="function">point <span class="title">excenter</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b, <span class="type">const</span> point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边的长度</span></span><br><span class="line">    <span class="type">double</span> ab = <span class="built_in">distance</span>(a, b);</span><br><span class="line">    <span class="type">double</span> bc = <span class="built_in">distance</span>(b, c);</span><br><span class="line">    <span class="type">double</span> ca = <span class="built_in">distance</span>(c, a);</span><br><span class="line">    <span class="comment">// 用旁切边权重计算旁心</span></span><br><span class="line">    <span class="keyword">return</span> &#123;(-ab * c.x + bc * a.x + ca * b.x) / (-ab + bc + ca),</span><br><span class="line">            (-ab * c.y + bc * a.y + ca * b.y) / (-ab + bc + ca)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    point a = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    point b = &#123;<span class="number">4</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    point c = &#123;<span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    point g = <span class="built_in">centroid</span>(a, b, c);</span><br><span class="line">    point h = <span class="built_in">orthocenter</span>(a, b, c);</span><br><span class="line">    point o = <span class="built_in">circumcenter</span>(a, b, c);</span><br><span class="line">    point i = <span class="built_in">incenter</span>(a, b, c);</span><br><span class="line">    point e = <span class="built_in">excenter</span>(a, b, c);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Centroid: (&quot;</span> &lt;&lt; g.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; g.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Orthocenter: (&quot;</span> &lt;&lt; h.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; h.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Circumcenter: (&quot;</span> &lt;&lt; o.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; o.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Incenter: (&quot;</span> &lt;&lt; i.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; i.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Excenter: (&quot;</span> &lt;&lt; e.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; e.y &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格拉汉姆扫描-Graham-Scan-计算面积"><a href="#格拉汉姆扫描-Graham-Scan-计算面积" class="headerlink" title="格拉汉姆扫描(Graham Scan)+计算面积"></a>格拉汉姆扫描(Graham Scan)+计算面积</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//计算三角形面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(point A, point B, point C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>((B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多边形面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polygonArea</span><span class="params">(<span class="type">const</span> vector&lt;point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">double</span> area = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 当前点 (x_i, y_i) 和下一点 (x_&#123;i+1&#125;, y_&#123;i+1&#125;)</span></span><br><span class="line">        <span class="type">int</span> next = (i + <span class="number">1</span>) % n;</span><br><span class="line">        area += points[i].x * points[next].y - points[i].y * points[next].x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(area) / <span class="number">2.0</span>; <span class="comment">// 取绝对值除以2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算两点之间的叉积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b, <span class="type">const</span> point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算两点之间的欧几里得距离（用于排序时的次要条件）</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">distance</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 起点（全局变量，用于排序）</span></span><br><span class="line">point pivot;</span><br><span class="line"><span class="comment">// 比较函数，用于极角排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">polarOrder</span><span class="params">(<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> cp = <span class="built_in">cross</span>(pivot, a, b);</span><br><span class="line">    <span class="keyword">if</span> (cp == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 共线点按距离从近到远排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">distance</span>(pivot, a) &lt; <span class="built_in">distance</span>(pivot, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cp &gt; <span class="number">0</span>; <span class="comment">// 逆时针为正序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Graham Scan 主函数</span></span><br><span class="line"><span class="function">vector&lt;point&gt; <span class="title">grahamScan</span><span class="params">(vector&lt;point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：找到 y 坐标最小的点（若相等，选择 x 坐标更小）</span></span><br><span class="line">    pivot = *<span class="built_in">min_element</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="type">const</span> point&amp; a, <span class="type">const</span> point&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y || (a.y == b.y &amp;&amp; a.x &lt; b.x);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 第二步：按极角排序</span></span><br><span class="line">    <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), polarOrder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：构建凸包</span></span><br><span class="line">    vector&lt;point&gt; hull; <span class="comment">// 栈，用于存储凸包点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : points) &#123;</span><br><span class="line">        <span class="comment">// 当栈顶点与新点构成的方向为顺时针或共线时，弹出栈顶</span></span><br><span class="line">        <span class="keyword">while</span> (hull.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">cross</span>(hull[hull.<span class="built_in">size</span>() - <span class="number">2</span>], hull.<span class="built_in">back</span>(), p) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hull.<span class="built_in">push_back</span>(p); <span class="comment">// 将当前点加入凸包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hull;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="function">vector&lt;point&gt; <span class="title">points</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;points[i].x,&amp;points[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;point&gt; scan=<span class="built_in">grahamScan</span>(points);</span><br><span class="line">        <span class="type">double</span> res=<span class="built_in">polygonArea</span>(scan);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Andrew扫描法-旋转卡壳法求凸包中两点最大距离"><a href="#Andrew扫描法-旋转卡壳法求凸包中两点最大距离" class="headerlink" title="Andrew扫描法+旋转卡壳法求凸包中两点最大距离"></a>Andrew扫描法+旋转卡壳法求凸包中两点最大距离</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>, <span class="type">long</span> <span class="type">long</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 向量叉积</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cross</span><span class="params">(<span class="type">const</span> Point&amp; O, <span class="type">const</span> Point&amp; A, <span class="type">const</span> Point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算两点之间距离平方</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dist2</span><span class="params">(<span class="type">const</span> Point&amp; A, <span class="type">const</span> Point&amp; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 凸包算法（Andrew算法）</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">convexHull</span><span class="params">(vector&lt;Point&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> points;</span><br><span class="line">    <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);</span><br><span class="line">    &#125;);</span><br><span class="line">    vector&lt;Point&gt; hull;</span><br><span class="line">    <span class="comment">// 下半部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; p : points) &#123;</span><br><span class="line">        <span class="keyword">while</span> (hull.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">cross</span>(hull[hull.<span class="built_in">size</span>() - <span class="number">2</span>], hull.<span class="built_in">back</span>(), p) &lt;= <span class="number">0</span>)</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        hull.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上半部分</span></span><br><span class="line">    <span class="type">int</span> t = hull.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (hull.<span class="built_in">size</span>() &gt;= t &amp;&amp; <span class="built_in">cross</span>(hull[hull.<span class="built_in">size</span>() - <span class="number">2</span>], hull.<span class="built_in">back</span>(), points[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">            hull.<span class="built_in">pop_back</span>();</span><br><span class="line">        hull.<span class="built_in">push_back</span>(points[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    hull.<span class="built_in">pop_back</span>(); <span class="comment">// 删除最后一个重复点</span></span><br><span class="line">    <span class="keyword">return</span> hull;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 旋转卡壳法求最大距离平方</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxDist2</span><span class="params">(<span class="type">const</span> vector&lt;Point&gt;&amp; hull)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = hull.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxDist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dist2</span>(hull[i], hull[(j + <span class="number">1</span>) % m]) &gt; <span class="built_in">dist2</span>(hull[i], hull[j]))</span><br><span class="line">            j = (j + <span class="number">1</span>) % m;</span><br><span class="line">        maxDist = <span class="built_in">max</span>(maxDist, <span class="built_in">dist2</span>(hull[i], hull[j]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;Point&gt; <span class="title">points</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; points[i].x &gt;&gt; points[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算凸包</span></span><br><span class="line">        vector&lt;Point&gt; hull = <span class="built_in">convexHull</span>(points);</span><br><span class="line">        <span class="comment">// 计算最大距离平方</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">maxDist2</span>(hull) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建模式串的部分匹配表（π函数或 next 数组）</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildNext</span><span class="params">(<span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m, <span class="number">0</span>)</span></span>; <span class="comment">// 初始化 next 数组，大小为 m，值为 0</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// j 是模式串的指针（前缀末尾）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从第二个字符开始计算 next 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果当前字符和前一个匹配的位置不相同，则回溯 j</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前字符和 j 指向的字符匹配，则 j 向后移动</span></span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j; <span class="comment">// 更新 next 数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP 匹配函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果模式串为空，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建部分匹配表（next 数组）</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">buildNext</span>(pattern);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// j 是模式串的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历文本串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果当前字符和 j 指向的字符不匹配，则回溯 j</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前字符匹配，则 j 向后移动</span></span><br><span class="line">        <span class="keyword">if</span> (text[i] == pattern[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果模式串完全匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>; <span class="comment">// 返回匹配的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果没有匹配，返回 -1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">KMP2</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; positions; <span class="comment">// 用于存储匹配的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果模式串为空，直接返回空结果</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> positions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建部分匹配表（next 数组）</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">buildNext</span>(pattern);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// j 是模式串的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历文本串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果当前字符和 j 指向的字符不匹配，则回溯 j</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前字符匹配，则 j 向后移动</span></span><br><span class="line">        <span class="keyword">if</span> (text[i] == pattern[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果模式串完全匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            positions.<span class="built_in">push_back</span>(i - m + <span class="number">1</span>); <span class="comment">// 记录匹配的起始位置</span></span><br><span class="line">            j = next[j - <span class="number">1</span>]; <span class="comment">// 继续查找下一个匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> positions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t; <span class="comment">// 输入测试用例数量</span></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        string s, t;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; t; <span class="comment">// 输入文本串和模式串</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans=<span class="built_in">KMP2</span>(s,t);</span><br><span class="line">        <span class="type">int</span> n=ans.<span class="built_in">size</span>();</span><br><span class="line">        cout&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i]<span class="number">+1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP-from-助教"><a href="#KMP-from-助教" class="headerlink" title="KMP from 助教"></a>KMP from 助教</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> _s[N];</span><br><span class="line"><span class="type">int</span> len[N];</span><br><span class="line"><span class="type">char</span> *s[N];</span><br><span class="line"><span class="type">int</span> r[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		s[i] = _s + p;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">		len[i] = <span class="built_in">strlen</span>(s[i] + <span class="number">1</span>);</span><br><span class="line">		p += len[i] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>, p = <span class="number">0</span>; j &lt;= len[i]; j++)&#123;</span><br><span class="line">			<span class="keyword">while</span> (p &amp;&amp; s[i][j] != s[i][p + <span class="number">1</span>])</span><br><span class="line">				p = r[p];</span><br><span class="line">			<span class="keyword">if</span> (s[i][j] == s[i][p + <span class="number">1</span>])</span><br><span class="line">				p++;</span><br><span class="line">			r[j] = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">			<span class="type">int</span> chk = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, p = <span class="number">0</span>; j &lt;= len[k]; j++)&#123;</span><br><span class="line">				<span class="keyword">while</span> (p &amp;&amp; s[k][j] != s[i][p + <span class="number">1</span>])</span><br><span class="line">					p = r[p];</span><br><span class="line">				<span class="keyword">if</span> (s[k][j] == s[i][p + <span class="number">1</span>])</span><br><span class="line">					p++;</span><br><span class="line">				<span class="keyword">if</span> (p == len[i])</span><br><span class="line">				&#123;</span><br><span class="line">					chk = <span class="number">1</span>;</span><br><span class="line">					p = r[p];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ans += chk;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// scanf(&quot;%d&quot;, &amp;T);</span></span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转移函数δ-x-c"><a href="#转移函数δ-x-c" class="headerlink" title="转移函数δ(x,c)"></a>转移函数δ(x,c)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造字符串自动机的转移函数</span></span><br><span class="line">vector&lt;unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">buildAutomaton</span>(<span class="type">const</span> string &amp;P) &#123;</span><br><span class="line">    <span class="type">int</span> m = P.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 构造失配指针</span></span><br><span class="line">    vector&lt;unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">automaton</span>(m + <span class="number">1</span>); <span class="comment">// 自动机的状态转移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算失配指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = fail[i];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; P[j] != P[i]) &#123;</span><br><span class="line">            j = fail[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (P[j] == P[i]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        fail[i + <span class="number">1</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造自动机转移函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt;= m; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123; <span class="comment">// 假设字符集为小写字母</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; m &amp;&amp; P[x] == c) &#123;</span><br><span class="line">                automaton[x][c] = x + <span class="number">1</span>; <span class="comment">// 匹配成功</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                automaton[x][c] = automaton[fail[x]][c]; <span class="comment">// 根据失配指针回退</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> automaton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string P = <span class="string">&quot;ababc&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> automaton = <span class="built_in">buildAutomaton</span>(P);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输出转移函数表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt;= P.<span class="built_in">size</span>(); x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">            cnt+=automaton[x][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建DFA的状态转移表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildDFA</span><span class="params">(<span class="type">const</span> string&amp; pattern, vector&lt;unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt;&amp; transitions, <span class="type">int</span>&amp; acceptState)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">length</span>();</span><br><span class="line">    transitions.<span class="built_in">resize</span>(m + <span class="number">1</span>); <span class="comment">// 总状态数为模式串长度 + 1</span></span><br><span class="line">    acceptState = m;          <span class="comment">// 接受状态为模式串长度</span></span><br><span class="line">    <span class="comment">// 初始化转移表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> state = <span class="number">0</span>; state &lt;= m; ++state) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c) &#123;</span><br><span class="line">            transitions[state][c] = <span class="number">0</span>; <span class="comment">// 默认跳转到初始状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> state = <span class="number">0</span>; state &lt; m; ++state) &#123;</span><br><span class="line">        <span class="type">char</span> c = pattern[state];</span><br><span class="line">        transitions[state][c] = state + <span class="number">1</span>; <span class="comment">// 匹配当前字符进入下一个状态</span></span><br><span class="line">        <span class="comment">// 处理失败转移</span></span><br><span class="line">        <span class="keyword">if</span> (state &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> fallback = transitions[state - <span class="number">1</span>][pattern[state]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> x = <span class="string">&#x27;a&#x27;</span>; x &lt;= <span class="string">&#x27;z&#x27;</span>; ++x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (transitions[state][x] == <span class="number">0</span>) &#123;</span><br><span class="line">                    transitions[state][x] = transitions[fallback][x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到目标串的位置</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findPositions</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> vector&lt;unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt;&amp; transitions, <span class="type">int</span> acceptState, <span class="type">int</span> patternLength)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; positions; <span class="comment">// 用于存储所有匹配的位置</span></span><br><span class="line">    <span class="type">int</span> state = <span class="number">0</span>;         <span class="comment">// 初始状态为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">char</span> c = text[i];</span><br><span class="line">        <span class="keyword">if</span> (transitions[state].<span class="built_in">count</span>(c) == <span class="number">0</span>) &#123;</span><br><span class="line">            state = <span class="number">0</span>; <span class="comment">// 未定义字符默认跳转到初始状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = transitions[state][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果到达接受状态，记录位置</span></span><br><span class="line">        <span class="keyword">if</span> (state == acceptState) &#123;</span><br><span class="line">            positions.<span class="built_in">push_back</span>(i - patternLength + <span class="number">1</span>); <span class="comment">// 起始位置 = 当前索引 - 模式串长度 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> positions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string pattern = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    string text = <span class="string">&quot;aababcdeabcabc&quot;</span>;</span><br><span class="line">    vector&lt;unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; transitions; <span class="comment">// 状态转移表</span></span><br><span class="line">    <span class="type">int</span> acceptState;</span><br><span class="line">    <span class="comment">// 构建DFA</span></span><br><span class="line">    <span class="built_in">buildDFA</span>(pattern, transitions, acceptState);</span><br><span class="line">    <span class="comment">// 找到匹配的位置</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; positions = <span class="built_in">findPositions</span>(text, transitions, acceptState, pattern.<span class="built_in">length</span>());</span><br><span class="line">    <span class="comment">// 输出匹配位置</span></span><br><span class="line">    <span class="keyword">if</span> (positions.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pattern not found in text.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pattern found at positions: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pos : positions) &#123;</span><br><span class="line">            cout &lt;&lt; pos &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h2><h3 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span>? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fastPower</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> exp, <span class="type">long</span> <span class="type">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;  <span class="comment">// 初始化结果为1</span></span><br><span class="line">    base = base % mod;     <span class="comment">// 处理base大于mod的情况</span></span><br><span class="line">    <span class="keyword">while</span> (exp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 exp 是奇数，将 base 乘到结果中</span></span><br><span class="line">        <span class="keyword">if</span> (exp % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            result = (result * base) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exp 变为 exp/2</span></span><br><span class="line">        exp = exp &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// base 自身相乘</span></span><br><span class="line">        base = (base * base) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">multiply</span><span class="params">(<span class="type">char</span> *num1, <span class="type">char</span> *num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">strlen</span>(num1);</span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(num1, <span class="string">&quot;0&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(num2, <span class="string">&quot;0&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *result = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(result, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *result = (<span class="type">int</span> *)<span class="built_in">calloc</span>(len1 + len2, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mul = (num1[i] - <span class="string">&#x27;0&#x27;</span>) * (num2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="type">int</span> p1 = i + j, p2 = i + j + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> sum = mul + result[p2];</span><br><span class="line">            result[p1] += sum / <span class="number">10</span>;</span><br><span class="line">            result[p2] = sum % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 + len2 &amp;&amp; result[i] == <span class="number">0</span>)</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *finalResult = (<span class="type">char</span> *)<span class="built_in">malloc</span>(len1 + len2 - i + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 + len2)</span><br><span class="line">    &#123;</span><br><span class="line">        finalResult[k++] = result[i++] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    finalResult[k] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">free</span>(result);</span><br><span class="line">    <span class="keyword">return</span> finalResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> n, <span class="type">long</span> <span class="type">long</span> A[<span class="number">128</span>][<span class="number">128</span>], <span class="type">long</span> <span class="type">long</span> B[<span class="number">128</span>][<span class="number">128</span>], <span class="type">long</span> <span class="type">long</span> AB[<span class="number">128</span>][<span class="number">128</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp[<span class="number">128</span>][<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            temp[i][j] = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                temp[i][j] = (temp[i][j] + A[i][k] * B[k][j]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            AB[i][j] = temp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">matrix_pow</span><span class="params">(<span class="type">int</span> n, <span class="type">long</span> <span class="type">long</span> A[<span class="number">128</span>][<span class="number">128</span>], <span class="type">long</span> <span class="type">long</span> m, <span class="type">long</span> <span class="type">long</span> res[<span class="number">128</span>][<span class="number">128</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp[<span class="number">128</span>][<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            res[i][j] = (i == j); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="built_in">multiply</span>(n, res, A, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">multiply</span>(n, A, A, A); </span><br><span class="line">        m /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><h4 id="从右到左"><a href="#从右到左" class="headerlink" title="从右到左"></a>从右到左</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=temperatures.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> t=temperatures[i];</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;t&gt;=temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans[i]=st.<span class="built_in">top</span>()-i;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从左到右"><a href="#从左到右" class="headerlink" title="从左到右"></a>从左到右</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t=temperatures[i];</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;t&gt;temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">            <span class="type">int</span> j=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ans[j]=i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="力扣962：最大宽度坡"><a href="#力扣962：最大宽度坡" class="headerlink" title="力扣962：最大宽度坡"></a>力扣962：最大宽度坡</h4><p>给定一个整数数组 A，坡是元组 (i, j)，其中  i &lt; j 且 A[i] &lt;&#x3D; A[j]。这样的坡的宽度为 j - i。<br>找出 A 中的坡的最大宽度，如果不存在，返回 0 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxWidthRamp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || nums[st.<span class="built_in">top</span>()] &gt; nums[i]) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[j] &gt;= nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>滑动窗口长度为k，求每个窗口的最大值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 1. 入</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt;= nums[i]) &#123;</span><br><span class="line">            q.<span class="built_in">pop_back</span>(); <span class="comment">// 维护 q 的单调性</span></span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(i); <span class="comment">// 入队</span></span><br><span class="line">        <span class="comment">// 2. 出</span></span><br><span class="line">        <span class="keyword">if</span> (i - q.<span class="built_in">front</span>() &gt;= k) &#123; <span class="comment">// 队首已经离开窗口了</span></span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 记录答案</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 由于队首到队尾单调递减，所以窗口最大值就是队首</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><h4 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义复数类型</span></span><br><span class="line"><span class="keyword">using</span> Complex = complex&lt;<span class="type">double</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算FFT的递归函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(vector&lt;Complex&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 基本情况：如果信号长度为1，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 分成偶数和奇数两部分</span></span><br><span class="line">    <span class="function">vector&lt;Complex&gt; <span class="title">even</span><span class="params">(n / <span class="number">2</span>)</span>, <span class="title">odd</span><span class="params">(n / <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        even[i] = a[<span class="number">2</span> * i];         <span class="comment">// 偶数项</span></span><br><span class="line">        odd[i] = a[<span class="number">2</span> * i + <span class="number">1</span>];      <span class="comment">// 奇数项</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归计算偶数部分和奇数部分的FFT</span></span><br><span class="line">    <span class="built_in">fft</span>(even);</span><br><span class="line">    <span class="built_in">fft</span>(odd);</span><br><span class="line">    <span class="comment">// 合并两个部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n / <span class="number">2</span>; k++) &#123;</span><br><span class="line">        Complex t = <span class="built_in">polar</span>(<span class="number">1.0</span>, <span class="number">-2</span> * M_PI * k / n) * odd[k];  <span class="comment">// 计算旋转因子</span></span><br><span class="line">        a[k] = even[k] + t;   <span class="comment">// 偶数项和旋转因子加和</span></span><br><span class="line">        a[k + n / <span class="number">2</span>] = even[k] - t;  <span class="comment">// 偶数项和旋转因子差</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印复数数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_complex_vector</span><span class="params">(<span class="type">const</span> vector&lt;Complex&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; c : v) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入信号（长度为2的幂）</span></span><br><span class="line">    vector&lt;Complex&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original signal: &quot;</span>;</span><br><span class="line">    <span class="built_in">print_complex_vector</span>(a);</span><br><span class="line">    <span class="comment">// 计算FFT</span></span><br><span class="line">    <span class="built_in">fft</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FFT result: &quot;</span>;</span><br><span class="line">    <span class="built_in">print_complex_vector</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FFT-from-助教"><a href="#FFT-from-助教" class="headerlink" title="FFT from 助教"></a>FFT from 助教</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">double</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ld pi = <span class="built_in">acosl</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">	ld r, i;</span><br><span class="line">	<span class="built_in">complex</span>() &#123; r = <span class="number">0</span>; i = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="built_in">complex</span>(ld re, ld im) &#123; r = re; i = im; &#125;</span><br><span class="line">	<span class="function">ld <span class="title">len2</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> r * r + i * i; &#125;</span><br><span class="line">	<span class="function">complex <span class="title">bar</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">complex</span>(r, -i); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">complex <span class="keyword">operator</span> + (<span class="type">const</span> complex &amp;x, <span class="type">const</span> complex &amp;y) &#123; <span class="keyword">return</span> <span class="built_in">complex</span>(x.r + y.r, x.i + y.i); &#125;</span><br><span class="line">complex <span class="keyword">operator</span> - (<span class="type">const</span> complex &amp;x, <span class="type">const</span> complex &amp;y) &#123; <span class="keyword">return</span> <span class="built_in">complex</span>(x.r - y.r, x.i - y.i); &#125;</span><br><span class="line">complex <span class="keyword">operator</span> * (ld x, <span class="type">const</span> complex &amp;y) &#123; <span class="keyword">return</span> <span class="built_in">complex</span>(x * y.r, x * y.i); &#125;</span><br><span class="line">complex <span class="keyword">operator</span> * (<span class="type">const</span> complex &amp;x, ld y) &#123; <span class="keyword">return</span> <span class="built_in">complex</span>(x.r * y, x.i * y); &#125;</span><br><span class="line">complex <span class="keyword">operator</span> * (<span class="type">const</span> complex &amp;x, <span class="type">const</span> complex &amp;y) &#123; <span class="keyword">return</span> <span class="built_in">complex</span>(x.r * y.r - x.i * y.i, x.r * y.i + x.i * y.r); &#125;</span><br><span class="line">complex <span class="keyword">operator</span> / (<span class="type">const</span> complex &amp;x, ld y) &#123; <span class="keyword">return</span> <span class="built_in">complex</span>(x.r / y, x.i / y); &#125;</span><br><span class="line">complex <span class="keyword">operator</span> / (<span class="type">const</span> complex &amp;x, <span class="type">const</span> complex &amp;y) &#123; <span class="keyword">return</span> x * y.<span class="built_in">bar</span>() / y.<span class="built_in">len2</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lens, lent, q;</span><br><span class="line"><span class="type">int</span> s[N], t[N];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line">complex a[N], b[N];</span><br><span class="line">complex v[N];</span><br><span class="line"><span class="type">int</span> rev[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dft</span><span class="params">(complex c[], <span class="type">int</span> inv = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		v[rev[i]] = c[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= len; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="function">complex <span class="title">wn</span><span class="params">(cosl(<span class="number">2</span> * pi / i), sinl(<span class="number">2</span> * pi / i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j += i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (i &gt;&gt; <span class="number">1</span>); k++)</span><br><span class="line">			&#123;</span><br><span class="line">				complex x = v[j + k], y = v[j + k + (i &gt;&gt; <span class="number">1</span>)] * w;</span><br><span class="line">				v[j + k] = x + y;</span><br><span class="line">				v[j + k + (i &gt;&gt; <span class="number">1</span>)] = x -y;</span><br><span class="line">				w = w * wn;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inv)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">			v[i] = v[i] / len;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = len - <span class="number">1</span>; i &lt; j; i++, j--)</span><br><span class="line">			<span class="built_in">swap</span>(v[i], v[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		c[i] = v[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;lens, &amp;lent, &amp;q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lens; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lent; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i]);</span><br><span class="line">	len = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (len &lt;= lens + lent + <span class="number">2</span>)</span><br><span class="line">		len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i] = b[i] = <span class="built_in">complex</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		ans[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lens; i++)</span><br><span class="line">		a[i] = <span class="built_in">complex</span>(s[i], <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lent; i++)</span><br><span class="line">		b[i] = <span class="built_in">complex</span>(t[i], <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		rev[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, t = i; j &lt; len; j &lt;&lt;= <span class="number">1</span>, t &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">			rev[i] &lt;&lt;= <span class="number">1</span>, rev[i] += t &amp; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dft</span>(a);</span><br><span class="line">	<span class="built_in">dft</span>(b);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		b[i] = a[i] * b[i];</span><br><span class="line">	<span class="built_in">dft</span>(b, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		ans[i] = <span class="built_in">round</span>(b[i].r);</span><br><span class="line">	<span class="keyword">while</span> (q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[k]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// scanf(&quot;%d&quot;, &amp;T);</span></span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="逆序置换"><a href="#逆序置换" class="headerlink" title="逆序置换"></a>逆序置换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">1500</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitReverse</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> logN)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> reversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; logN; ++i) &#123;</span><br><span class="line">        reversed = (reversed &lt;&lt; <span class="number">1</span>) | (num &amp; <span class="number">1</span>);</span><br><span class="line">        num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reversed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> logN=<span class="built_in">log2</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> rev = <span class="built_in">bitReverse</span>(arr[i], logN);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, rev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同余方程的最小正整数解"><a href="#同余方程的最小正整数解" class="headerlink" title="同余方程的最小正整数解"></a>同余方程的最小正整数解</h3><p><strong>扩展欧几里得算法</strong></p>
<h4 id="ax-≡-1-mod-b"><a href="#ax-≡-1-mod-b" class="headerlink" title="ax ≡ 1 (mod b)"></a>ax ≡ 1 (mod b)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展欧几里得算法</span></span><br><span class="line"><span class="comment">// 返回gcd, x, y满足 ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extendedGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">extendedGCD</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求 a 模 b 的乘法逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">modInverse</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">extendedGCD</span>(a, b, x, y);</span><br><span class="line">    <span class="keyword">if</span> (gcd != <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有解，a 和 b 必须互质。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果 gcd(a, b) != 1，则没有逆元</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 乘法逆元 x 可能是负数，需要调整为正数</span></span><br><span class="line">        <span class="built_in">return</span> (x % b + b) % b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="type">int</span> inverse = <span class="built_in">modInverse</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (inverse != <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;最小正整数解 x = &quot;</span> &lt;&lt; inverse &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ax-≡-b-mod-n"><a href="#ax-≡-b-mod-n" class="headerlink" title="ax ≡ b (mod n)"></a>ax ≡ b (mod n)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展欧几里得算法，求解 ax + ny = gcd(a, n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extendedGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">// gcd(a, 0) = a</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">extendedGCD</span>(n, a % n, x, y);</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp - (a / n) * y;</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求解同余方程 ax ≡ b (mod n) 的最小正整数解</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solveCongruence</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> g = <span class="built_in">extendedGCD</span>(a, n, x, y);</span><br><span class="line">    <span class="comment">// 如果 gcd(a, n) 不整除 b, 无解</span></span><br><span class="line">    <span class="keyword">if</span> (b % g != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 无解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有解，缩放解，使得解是最小的</span></span><br><span class="line">    x = (x * (b / g)) % n;</span><br><span class="line">    <span class="comment">// 如果 x 为负数，则加上 n 使其为正数</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, n;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">solveCongruence</span>(a, b, n);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;该同余方程无解。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手搓堆"><a href="#手搓堆" class="headerlink" title="手搓堆"></a>手搓堆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *y;</span><br><span class="line">    *y = *x;</span><br><span class="line">    *x = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> heap[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    heap[++len] = x;</span><br><span class="line">    <span class="type">int</span> i = len;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">1</span> &amp;&amp; heap[i] &gt; heap[i &gt;&gt; <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;heap[i], &amp;heap[i &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        i &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>] = heap[len--];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;&lt; <span class="number">1</span> &lt;= len) &#123;</span><br><span class="line">        <span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; len &amp;&amp; heap[j] &lt; heap[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (heap[i] &gt;= heap[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;heap[i], &amp;heap[j]);</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> originalLen = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;heap[<span class="number">1</span>], &amp;heap[len]);</span><br><span class="line">        len--; </span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;&lt; <span class="number">1</span> &lt;= len) &#123;</span><br><span class="line">            <span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; len &amp;&amp; heap[j] &lt; heap[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] &gt;= heap[j]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(&amp;heap[i], &amp;heap[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    len = originalLen; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 质因数分解函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">primeFactors</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; factors;  <span class="comment">// 用于存储质因数</span></span><br><span class="line">    <span class="comment">// 先处理2的因数</span></span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        factors.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理大于2的奇数因数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="built_in">sqrt</span>(n); i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            factors.<span class="built_in">push_back</span>(i);</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果n本身是一个质数且大于2</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        factors.<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factors;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line">    <span class="keyword">if</span> (number &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please enter a number greater than 1.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; factors = <span class="built_in">primeFactors</span>(number);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Prime factors of &quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> factor : factors) &#123;</span><br><span class="line">        cout &lt;&lt; factor &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, TrieNode*&gt; children; </span><br><span class="line">    <span class="type">int</span> count; </span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">count</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TrieNode* <span class="title">createTrie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TrieNode* root, <span class="type">const</span> string&amp; word, unordered_set&lt;string&gt;&amp; history)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已经有了(如果不限制重复的话，就不需要这个判断)</span></span><br><span class="line">    <span class="keyword">if</span> (history.<span class="built_in">find</span>(word) != history.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    history.<span class="built_in">insert</span>(word);</span><br><span class="line">    TrieNode* node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children.<span class="built_in">find</span>(c) == node-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[c];</span><br><span class="line">        node-&gt;count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(TrieNode* root, <span class="type">const</span> string&amp; prefix)</span> </span>&#123;</span><br><span class="line">    TrieNode* node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children.<span class="built_in">find</span>(c) == node-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 前缀不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;children[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;count; <span class="comment">// 返回前缀计数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">freeTrie</span><span class="params">(TrieNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">freeTrie</span>(child.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    TrieNode* root = <span class="built_in">createTrie</span>();</span><br><span class="line">    unordered_set&lt;string&gt; history;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="built_in">insert</span>(root, str, history);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">query</span>(root, str) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">freeTrie</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="银行利息"><a href="#银行利息" class="headerlink" title="银行利息"></a>银行利息</h3><p>在第 1 天，有一个人发现了一个秘密。<br>给你一个整数 delay ，表示每个人会在发现秘密后的 delay 天之后，<br>每天 给一个新的人 分享 秘密。同时给你一个整数 forget ，表示每个人在发现秘密 forget 天之后会 忘记 这个秘密。<br>一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。<br>给你一个整数 n ，请你返回在第 n 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 109 + 7 取余 后返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">peopleAwareOfSecret</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> delay, <span class="type">int</span> forget)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> f[n]; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + delay &gt;= n) cnt_b = (cnt_b + f[i]) % MOD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + delay; j &lt; <span class="built_in">min</span>(i + forget, n); ++j)</span><br><span class="line">            f[j] = (f[j] + f[i]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (f[n - <span class="number">1</span>] + cnt_b) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j<span class="number">+1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> temp;</span><br><span class="line">                temp=a[j];a[j]=a[j<span class="number">+1</span>];a[j<span class="number">+1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将a[s...m]和a[m+1...e]两个有序子序列归并为有序</span></span><br><span class="line"><span class="comment">// 归并后的序列存放数组b中 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> s, <span class="type">int</span> m, <span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i,j,k;<span class="comment">// 申请临时空间存放有序序列 </span></span><br><span class="line">  <span class="type">int</span> *b = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*(e-s<span class="number">+1</span>));</span><br><span class="line">  <span class="keyword">for</span>(i=m<span class="number">+1</span>,k=<span class="number">0</span>,j=s; j&lt;=m &amp;&amp; i&lt;=e; ++k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[j] &lt;= a[i])b[k] = a[j++];</span><br><span class="line">    <span class="keyword">else</span> b[k] = a[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=m) &#123;</span><br><span class="line">    b[k] = a[j];k++;j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=e)&#123;</span><br><span class="line">    b[k] = a[i];k++;i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 排序完成后，复制到原数组a</span></span><br><span class="line">  <span class="keyword">for</span>(i=s,k=<span class="number">0</span>; i&lt;=e; i++,k++) a[i] = b[k];</span><br><span class="line">  <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对a[s...e]序列进行归并排序 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> s, <span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s&lt;e)&#123;</span><br><span class="line">    <span class="comment">// 将整个序列一分为二 </span></span><br><span class="line">    <span class="type">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">msort</span>(a,s,m);</span><br><span class="line">    <span class="built_in">msort</span>(a,m<span class="number">+1</span>,e);</span><br><span class="line">    <span class="built_in">merge</span>(a,s,m,e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="built_in">msort</span>(a,<span class="number">0</span>,length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">merge_sort</span>(a,<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆序k倍对-如果-1-≤-i-j≤n-且-ai-k⋅aj"><a href="#逆序k倍对-如果-1-≤-i-j≤n-且-ai-k⋅aj" class="headerlink" title="逆序k倍对(如果 1 ≤ i &lt; j≤n 且 ai &gt; k⋅aj)"></a>逆序k倍对(如果 1 ≤ i &lt; j≤n 且 ai &gt; k⋅aj)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">500010</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> invCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n;<span class="type">int</span> key;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeAndCount</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> leftSize = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rightSize = right - mid;</span><br><span class="line">    <span class="type">int</span> leftArr[leftSize], rightArr[rightSize];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; leftSize; i++)</span><br><span class="line">        leftArr[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rightSize; i++)</span><br><span class="line">        rightArr[i] = arr[mid + <span class="number">1</span> + i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftSize &amp;&amp; j &lt; rightSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &gt; key * rightArr[j]) &#123;</span><br><span class="line">            invCount += (leftSize - i);</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftSize &amp;&amp; j &lt; rightSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArr[i] &lt;= rightArr[j]) &#123;</span><br><span class="line">            arr[k++] = leftArr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k++] = rightArr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; leftSize)</span><br><span class="line">        arr[k++] = leftArr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; rightSize)</span><br><span class="line">        arr[k++] = rightArr[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序并统计逆序对</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inverse</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">inverse</span>(left, mid);</span><br><span class="line">        <span class="built_in">inverse</span>(mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">mergeAndCount</span>(left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    invCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">inverse</span>(<span class="number">0</span>, n - <span class="number">1</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, invCount); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半插入排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binaryInsertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 使用二分查找确定插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; key) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将大于 key 的元素向后移动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入 key 到正确的位置</span></span><br><span class="line">        arr[left] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;给定数组是:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line">    <span class="built_in">binaryInsertionSort</span>(arr, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组是:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">### 希尔</span><br><span class="line">```<span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li>DFS <strong>O(V+E)</strong></li>
<li>BFS <strong>O(V+E)</strong></li>
<li>拓扑排序 <strong>O(V+E)</strong></li>
<li>Prim<ul>
<li>使用邻接矩阵 <strong>O(V^2)</strong></li>
<li>使用邻接表和最小堆 <strong>O((V + E) log V)</strong></li>
</ul>
</li>
<li>Kruskal <strong>O(E log E)</strong></li>
<li>Dijkstra<ul>
<li>使用邻接矩阵(朴素) <strong>O(V^2)</strong></li>
<li>使用邻接表和最小堆 <strong>O((V + E) log V)</strong></li>
</ul>
</li>
<li>Bellman-Ford <strong>O(VE)</strong></li>
<li>Floyd <strong>O(V^3)</strong></li>
<li>并查集<ul>
<li>无优化 <strong>O(V)</strong></li>
<li>按秩合并和路径压缩优化：**O(α(V))**，其中 α(V) 是阿克曼函数的反函数，增长非常慢，接近常数时间。</li>
</ul>
</li>
<li>Dinic <strong>O(EV^2)</strong>  ,(在一些特殊情况下，可以达到 O(E * sqrt(V))。)</li>
<li>Ford-Fulkerson <strong>O(EF)</strong>  (F是最大流的大小)</li>
<li>Edmonds-Karp <strong>O(VE^2)</strong></li>
<li>Graham扫描 <strong>O(nlogn)</strong></li>
<li>Andrew 扫描 <strong>O(nlogn)</strong></li>
<li>Jarvis算法 <strong>O(nh)</strong>  (h 是凸包上的点数)</li>
<li>KMP <strong>O(n+m)</strong> (其中 n 是文本的长度，m 是模式串的长度)</li>
<li>计算gcd <strong>O(log(min(a, b)))</strong></li>
<li>lcm <strong>O(log(min(a, b)))</strong></li>
<li>快速幂 <strong>O(logn)</strong> (n是次方数)</li>
<li>单调栈 <strong>O(n)</strong></li>
<li>单调队列 <strong>O(n)</strong></li>
<li>DFT <strong>O(nlogn)</strong></li>
<li>FFT <strong>O(nlogn)</strong></li>
<li>字典树<ul>
<li>插入：**O(m)**，其中 m 是单词的长度。</li>
<li>查询：**O(m)**，同样与单词的长度有关。</li>
<li>空间复杂度：**O(m * N)**，其中 m 是最大单词长度，N 是字典中单词的数量。</li>
</ul>
</li>
<li>堆<ul>
<li>插入元素并维护堆的性质：<strong>O(logn)</strong></li>
<li>删除堆顶并维护堆的性质：<strong>O(logn)</strong></li>
<li>Heapify将一个无序数组转换为一个堆：<strong>O(n)</strong></li>
<li>堆排序 <strong>O(nlogn)</strong></li>
</ul>
</li>
<li>猴子排序 <strong>O(1145141919810)</strong></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/11/12/CO4/" rel="prev" title="MIPS处理器">
                  <i class="fa fa-angle-left"></i> MIPS处理器
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/11/18/transformer/" rel="next" title="我对Transformer的理解">
                  我对Transformer的理解 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">PIGMilk</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"http://example.com/2024/11/17/banzi/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
